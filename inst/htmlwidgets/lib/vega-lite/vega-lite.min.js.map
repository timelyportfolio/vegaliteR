{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/datalib/node_modules/d3-time/build/d3-time.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/time.js","node_modules/datalib/src/util.js","src/aggregate.ts","src/bin.ts","src/channel.ts","src/compiler/Model.ts","src/compiler/axis.ts","src/compiler/compiler.ts","src/compiler/data.ts","src/compiler/facet.ts","src/compiler/layout.ts","src/compiler/legend.ts","src/compiler/marks.ts","src/compiler/scale.ts","src/compiler/stack.ts","src/compiler/time.ts","src/data.ts","src/encoding.ts","src/fielddef.ts","src/marktype.ts","src/schema/axis.schema.ts","src/schema/bin.schema.ts","src/schema/config.schema.ts","src/schema/data.schema.ts","src/schema/encoding.schema.ts","src/schema/fielddef.schema.ts","src/schema/legend.schema.ts","src/schema/marktype.schema.ts","src/schema/scale.schema.ts","src/schema/schema.ts","src/schema/schemautil.ts","src/schema/sort.schema.ts","src/shorthand.ts","src/spec.ts","src/timeunit.ts","src/type.ts","src/util.ts","src/validate.ts","src/vl.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"factory","d3_time","newInterval","floori","offseti","count","interval","date","Date","floor","round","d0","d1","ceil","offset","step","Math","range","start","stop","push","filter","test","setTime","end","t0","t1","weekday","setHours","setDate","getDate","getDay","getTimezoneOffset","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","millisecond","second","setMilliseconds","minute","setSeconds","hour","setMinutes","day","sunday","monday","tuesday","wednesday","thursday","friday","saturday","month","setMonth","getMonth","getFullYear","year","setFullYear","utcSecond","setUTCMilliseconds","utcMinute","setUTCSeconds","utcHour","setUTCMinutes","utcDay","utcSunday","utcMonday","utcTuesday","utcWednesday","utcThursday","utcFriday","utcSaturday","utcMonth","setUTCMonth","getUTCMonth","getUTCFullYear","utcYear","setUTCFullYear","milliseconds","seconds","minutes","hours","days","sundays","mondays","tuesdays","wednesdays","thursdays","fridays","saturdays","weeks","months","years","utcMillisecond","utcMilliseconds","utcSeconds","utcMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesdays","utcWednesdays","utcThursdays","utcFridays","utcSaturdays","utcWeeks","utcMonths","utcYears","version","week","utcWeek",3,"bins","opt","level","minstep","precision","v","eps","maxb","maxbins","base","logb","log","div","min","max","span","steps","bisect","pow","unit","value","index","x","lo","hi","mid","util","cmp","EPSILON","date_value","date_index","time","units","utc","dmin","dmax","minb","minbins","find","spec","raw","../time","../util",4,"gen","repeat","val","Array","zeros","arguments","Infinity","j","random","uniform","undefined","d","samples","map","integer","b","normal","mean","stdev","next","rds","c","y","sqrt",5,"annotation","data","types","TYPES","type","values","array","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","keys","reduce","infer","TESTS","splice","inferAll","PARSERS","boolean","number","string","isNaN","parse","all","parsers",6,"stats","unique","results","valid","missing","distinct","median","sort","quantile","quartile","q","p","identity","H","h","sum","delta","variance","isArray","M2","modeskew","avg","med","std","extent","dot","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","isFunction","L2","abs","m","R","M","entropy","counts","LN2","mutual","z","px","py","I","info","profile","sd","vals","q1","q3","summary","field","__summary__","./generate","./import/type","./util",7,"tempDate","entry","create","STEPS","toUnitMap","baseDate","utcBaseDate","UTC","locale","getSeconds","getMinutes","getHours","getUTCSeconds","getUTCMinutes","getUTCHours","d3-time",8,"util_escape_str","replace","escape_str_re","strrep","str","truncateOnWord","len","rev","cnt","tok","split","truncate_word_re","reverse","w","join","trim","slice","buffer","FNAME","namedfunc","name","duplicate","obj","JSON","stringify","equal","extend","k","toMap","list","keystr","String","toString","Object","prototype","isObject","isBuffer","Buffer","field_re","match","accessor","mutator","$func","op","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","pad","pos","padchar","truncate","word","ellipsis","l1","l2","./time",9,"AGGREGATE_OPS","SHARED_DOMAIN_OPS",10,"MAXBINS_DEFAULT",11,"supportMarktype","channel","marktype","getSupportedMarktype","point","tick","circle","square","bar","line","area","ROW","COLUMN","text","SIZE","COLOR","DETAIL","SHAPE","TEXT","getSupportedRole","measure","dimension","CHANNELS",12,"bin_1","channel_1","data_1","vlFieldDef","vlEncoding","layout_1","marktype_1","schema","schemaUtil","type_1","util_1","Model","theme","numberFormat","config","defaults","instantiate","_spec","merge","forEach","encoding","fieldDef","getFullName","_stack","getStackProperties","_layout","compileLayout","stackChannel","has","is","BAR","AREA","isAggregate","isXMeasure","isMeasure","isYMeasure","groupbyChannel","fieldChannel","layout","stack","toSpec","excludeConfig","excludeData","subtract","datum","prefn","isCount","nofn","bin","binSuffix","noAggregate","aggregate","timeUnit","fieldTitle","COUNT_DISPLAYNAME","toUpperCase","init","isOrdinalScale","contains","NOMINAL","ORDINAL","TEMPORAL","scale","isDimension","isFacet","dataTable","SUMMARY","SOURCE","hasValues","../bin","../channel","../data","../encoding","../fielddef","../marktype","../schema/schema","../schema/schemautil","../type","./layout",13,"compileAxis","model","isCol","isRow","def","property","method","axis","props","properties","group","format","QUANTITATIVE","grid","layer","gridOffset","orient","ticks","tickSize","title","axisSpec","maxLength","titleMaxLength","cellWidth","cellHeight","opacity","labels","filterName","labelTemplate","shortTimeNames","template","labelMaxLength","angle","align","baseline",14,"compile","Model_1","rootGroup","from","data_2","LAYOUT","update","width","height","marks","marks_1","compileMarks","facet_1","facetMixins","scaleNames","_","scales","scale_1","compileScales","axes","axis_1","concat","legends","legend_1","compileLegends","FIT","output","padding","compileData","Model_2","./Model","./axis","./data","./facet","./legend","./marks","./scale",15,"source","summaryDef","filterNonPositiveForLog","statsDef","stackDef","transform","source_1","url","formatType","formatParse","nullFilterTransform","formulaTransform","timeTransform","binTransform","filterTransform","expr","formula","filterNull","filteredFields","fieldName","calculate","summarize","formulas","ops","xScale","bandWidth","yScale","cellPadding","distinctCol","distinctRow","dims","meas","hasAggregate","groupby","fnDictSet","stackProps","facetFields","stacked","STACKED",16,"band","facetGroupProperties","cellConfig","rootMarks","rootAxes","facetKeys","cellAxes","hasRow","hasCol","error","getXAxesGroup","getRowRulesGroup","getYAxesGroup","getColumnRulesGroup","facetGroup","xAxesGroup","yAxesGroup","rowRulesOnTop","rowRules","x2","stroke","gridColor","strokeOpacity","gridOpacity","parent","colRulesOnLeft","columnRules","y2",17,"getCellWidth","getCellHeight","getWidth","getHeight",18,"defs","legend","compileLegend","fill","size","shape","symbols","filled","strokeWidth",19,"LINE","sortField","pathMarks","MARKTYPES_MAP","by","details","detailFields","facetTransform","stack_1","imputeTransform","stackTransform","textBackground","mainDef","xc","yc","marksConfig","filled_point_props","fontSize","./stack",20,"names","scaleDef","domain","rangeMixins","facet","useRawDomain","_useRawDomain","domainSort","order","aggregate_1","indexOf","scaleType","clamp","exponent","nice","outerPadding","points","rangeMin","rangeMax","zero","../aggregate",21,"orderby","sortby","valName",22,"cardinality","stat","yearstat","scaleLabel","labelLength","substr","isOrdinalFn","abbreviated","postfix","isColor",23,"./type",24,"countRetinal","color","arr","./channel",25,"_isFieldDimension","displayName","getbins","./bin","./compiler/time",26,"POINT","TICK","CIRCLE","SQUARE",27,"default","description","enum","minimum","titleOffset",28,"supportedTypes",29,"viewport","items","nominal","ordinal","quantitative","temporal","textCellWidth","sortLineBy","oneOf","cell","role","maximum","fillOpacity","strokeDash","strokeDashOffset","font","fontStyle","fontWeight","singleBarOffset","characterWidth","timeFormat",30,"additionalProperties",31,"schemautil_1","axis_schema_1","legend_schema_1","sort_schema_1","fielddef_schema_1","requiredNameType","required","typicalField","onlyOrdinalField","row","column","quantitativeRange","minItems","maxItems","detail","./axis.schema","./fielddef.schema","./legend.schema","./schemautil","./sort.schema",32,"bin_schema_1","scale_schema_1","timeunit_1","TIMEUNITS","supportedEnums","","typicalScale","ordinalOnlyScale","../timeunit","./bin.schema","./scale.schema",33,34,35,"ordinalScaleMixin","typicalScaleMixin",36,"marktype_schema_1","config_schema_1","data_schema_1","encoding_schema_1","$schema","./config.schema","./data.schema","./encoding.schema","./marktype.schema",37,"isEmpty","instance","changes","prop","ins","dest","src","_i","merge_","hasOwnProperty","constructor",38,39,"shorten","ASSIGN","DELIM","shortenEncoding","shorthand","shift","parseEncoding","shortenFieldDef","encodingShorthand","enctype","fieldDefShorthand","parseFieldDef","FUNC","TYPE","SHORT_TYPE","shortenFieldDefs","fieldDefs","delim","TYPE_FROM_SHORT_TYPE","tu","./aggregate","./encoding","./timeunit",40,"alwaysNoOcclusion","getCleanSpec","isStack","transpose","oldenc","./compiler/Model","./marktype",41,42,"toLowerCase","Q","T","O","N",43,"__export","item","thisArg","any","dlBin","message","console","datalib/src/bins/bins","datalib/src/generate","datalib/src/stats","datalib/src/util",44,"getEncodingMappingError","requiredChannelMap","supportedChannelMap","DEFAULT_REQUIRED_CHANNEL_MAP","DEFAULT_SUPPORTED_CHANNEL_TYPE","requiredChannels","supportedChannels",45,"vlBin","vlChannel","vlData","vlCompiler","vlSchema","vlShorthand","vlSpec","vlTimeUnit","vlType","vlValidate","vlUtil","compiler","validate","./compiler/compiler","./fielddef","./schema/schema","./shorthand","./spec","./validate"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.0.7\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));\n},{}],3:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":7,\"../util\":8}],4:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\n},{}],5:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n\n},{\"../util\":8}],6:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n\n},{\"./generate\":4,\"./import/type\":5,\"./util\":8}],7:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":2}],8:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":7,\"buffer\":1}],9:[function(require,module,exports){\nexports.AGGREGATE_OPS = [\r\n    'values', 'count', 'valid', 'missing', 'distinct',\r\n    'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\r\n    'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\r\n    'argmin', 'argmax'\r\n];\r\nexports.SHARED_DOMAIN_OPS = [\r\n    'mean', 'average', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'min', 'max'\r\n];\r\n},{}],10:[function(require,module,exports){\nexports.MAXBINS_DEFAULT = 15;\r\n},{}],11:[function(require,module,exports){\nexports.X = 'x';\r\nexports.Y = 'y';\r\nexports.ROW = 'row';\r\nexports.COLUMN = 'column';\r\nexports.SHAPE = 'shape';\r\nexports.SIZE = 'size';\r\nexports.COLOR = 'color';\r\nexports.TEXT = 'text';\r\nexports.DETAIL = 'detail';\r\nexports.CHANNELS = [exports.X, exports.Y, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.TEXT, exports.DETAIL];\r\n;\r\nfunction supportMarktype(channel, marktype) {\r\n    return !!getSupportedMarktype(channel)[marktype];\r\n}\r\nexports.supportMarktype = supportMarktype;\r\nfunction getSupportedMarktype(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SIZE:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, text: true\r\n            };\r\n        case exports.COLOR:\r\n        case exports.DETAIL:\r\n            return {\r\n                point: true, tick: true, circle: true, square: true,\r\n                bar: true, line: true, area: true, text: true\r\n            };\r\n        case exports.SHAPE:\r\n            return { point: true };\r\n        case exports.TEXT:\r\n            return { text: true };\r\n    }\r\n    return {};\r\n}\r\nexports.getSupportedMarktype = getSupportedMarktype;\r\n;\r\nfunction getSupportedRole(channel) {\r\n    switch (channel) {\r\n        case exports.X:\r\n        case exports.Y:\r\n        case exports.COLOR:\r\n            return {\r\n                measure: true,\r\n                dimension: true\r\n            };\r\n        case exports.ROW:\r\n        case exports.COLUMN:\r\n        case exports.SHAPE:\r\n        case exports.DETAIL:\r\n            return {\r\n                measure: false,\r\n                dimension: true\r\n            };\r\n        case exports.SIZE:\r\n        case exports.TEXT:\r\n            return {\r\n                measure: true,\r\n                dimension: false\r\n            };\r\n    }\r\n    throw new Error('Invalid encoding channel' + channel);\r\n}\r\nexports.getSupportedRole = getSupportedRole;\r\n},{}],12:[function(require,module,exports){\nvar bin_1 = require('../bin');\r\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nvar vlFieldDef = require('../fielddef');\r\nvar vlEncoding = require('../encoding');\r\nvar layout_1 = require('./layout');\r\nvar marktype_1 = require('../marktype');\r\nvar schema = require('../schema/schema');\r\nvar schemaUtil = require('../schema/schemautil');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nvar time = require('./time');\r\nvar Model = (function () {\r\n    function Model(spec, theme) {\r\n        this.numberFormat = function (channel) {\r\n            return this.config('numberFormat');\r\n        };\r\n        var defaults = schema.instantiate();\r\n        this._spec = schemaUtil.merge(defaults, theme || {}, spec);\r\n        vlEncoding.forEach(this._spec.encoding, function (fieldDef, channel) {\r\n            if (fieldDef.type) {\r\n                fieldDef.type = type_1.getFullName(fieldDef.type);\r\n            }\r\n        });\r\n        this._stack = this.getStackProperties();\r\n        this._layout = layout_1.compileLayout(this);\r\n    }\r\n    Model.prototype.getStackProperties = function () {\r\n        var stackChannel = (this.has(channel_1.COLOR)) ? channel_1.COLOR : (this.has(channel_1.DETAIL)) ? channel_1.DETAIL : null;\r\n        if (stackChannel &&\r\n            (this.is(marktype_1.BAR) || this.is(marktype_1.AREA)) &&\r\n            this.config('stack') !== false &&\r\n            this.isAggregate()) {\r\n            var isXMeasure = this.isMeasure(channel_1.X);\r\n            var isYMeasure = this.isMeasure(channel_1.Y);\r\n            if (isXMeasure && !isYMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.Y,\r\n                    fieldChannel: channel_1.X,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n            else if (isYMeasure && !isXMeasure) {\r\n                return {\r\n                    groupbyChannel: channel_1.X,\r\n                    fieldChannel: channel_1.Y,\r\n                    stackChannel: stackChannel,\r\n                    config: this.config('stack')\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Model.prototype.layout = function () {\r\n        return this._layout;\r\n    };\r\n    Model.prototype.stack = function () {\r\n        return this._stack;\r\n    };\r\n    Model.prototype.toSpec = function (excludeConfig, excludeData) {\r\n        var encoding = util_1.duplicate(this._spec.encoding), spec;\r\n        spec = {\r\n            marktype: this._spec.marktype,\r\n            encoding: encoding\r\n        };\r\n        if (!excludeConfig) {\r\n            spec.config = util_1.duplicate(this._spec.config);\r\n        }\r\n        if (!excludeData) {\r\n            spec.data = util_1.duplicate(this._spec.data);\r\n        }\r\n        var defaults = schema.instantiate();\r\n        return schemaUtil.subtract(spec, defaults);\r\n    };\r\n    Model.prototype.marktype = function () {\r\n        return this._spec.marktype;\r\n    };\r\n    Model.prototype.is = function (m) {\r\n        return this._spec.marktype === m;\r\n    };\r\n    Model.prototype.has = function (channel) {\r\n        return this._spec.encoding[channel].field !== undefined;\r\n    };\r\n    Model.prototype.fieldDef = function (channel) {\r\n        return this._spec.encoding[channel];\r\n    };\r\n    Model.prototype.field = function (channel, opt) {\r\n        opt = opt || {};\r\n        var fieldDef = this.fieldDef(channel);\r\n        var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''), field = fieldDef.field;\r\n        if (vlFieldDef.isCount(fieldDef)) {\r\n            return f + 'count';\r\n        }\r\n        else if (opt.fn) {\r\n            return f + opt.fn + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.bin) {\r\n            var binSuffix = opt.binSuffix || '_start';\r\n            return f + 'bin_' + field + binSuffix;\r\n        }\r\n        else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\r\n            return f + fieldDef.aggregate + '_' + field;\r\n        }\r\n        else if (!opt.nofn && fieldDef.timeUnit) {\r\n            return f + fieldDef.timeUnit + '_' + field;\r\n        }\r\n        else {\r\n            return f + field;\r\n        }\r\n    };\r\n    Model.prototype.fieldTitle = function (channel) {\r\n        if (vlFieldDef.isCount(this._spec.encoding[channel])) {\r\n            return vlFieldDef.COUNT_DISPLAYNAME;\r\n        }\r\n        var fn = this._spec.encoding[channel].aggregate || this._spec.encoding[channel].timeUnit || (this._spec.encoding[channel].bin && 'bin');\r\n        if (fn) {\r\n            return fn.toUpperCase() + '(' + this._spec.encoding[channel].field + ')';\r\n        }\r\n        else {\r\n            return this._spec.encoding[channel].field;\r\n        }\r\n    };\r\n    Model.prototype.bin = function (channel) {\r\n        var bin = this._spec.encoding[channel].bin;\r\n        if (bin === {})\r\n            return false;\r\n        if (bin === true)\r\n            return {\r\n                maxbins: bin_1.MAXBINS_DEFAULT\r\n            };\r\n        return bin;\r\n    };\r\n    Model.prototype.map = function (f) {\r\n        return vlEncoding.map(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.reduce = function (f, init) {\r\n        return vlEncoding.reduce(this._spec.encoding, f, init);\r\n    };\r\n    Model.prototype.forEach = function (f) {\r\n        return vlEncoding.forEach(this._spec.encoding, f);\r\n    };\r\n    Model.prototype.isOrdinalScale = function (channel) {\r\n        var fieldDef = this.fieldDef(channel);\r\n        return fieldDef && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) ||\r\n            (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit &&\r\n                time.scale.type(fieldDef.timeUnit, channel) === 'ordinal'));\r\n    };\r\n    Model.prototype.isDimension = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isDimension(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isMeasure = function (channel) {\r\n        return this.has(channel) &&\r\n            vlFieldDef.isMeasure(this.fieldDef(channel));\r\n    };\r\n    Model.prototype.isAggregate = function () {\r\n        return vlEncoding.isAggregate(this._spec.encoding);\r\n    };\r\n    Model.prototype.isFacet = function () {\r\n        return this.has(channel_1.ROW) || this.has(channel_1.COLUMN);\r\n    };\r\n    Model.prototype.dataTable = function () {\r\n        return this.isAggregate() ? data_1.SUMMARY : data_1.SOURCE;\r\n    };\r\n    Model.prototype.data = function () {\r\n        return this._spec.data;\r\n    };\r\n    Model.prototype.hasValues = function () {\r\n        var vals = this.data().values;\r\n        return vals && vals.length;\r\n    };\r\n    Model.prototype.config = function (name) {\r\n        return this._spec.config[name];\r\n    };\r\n    return Model;\r\n})();\r\nexports.Model = Model;\r\n},{\"../bin\":10,\"../channel\":11,\"../data\":23,\"../encoding\":24,\"../fielddef\":25,\"../marktype\":26,\"../schema/schema\":36,\"../schema/schemautil\":37,\"../type\":42,\"../util\":43,\"./layout\":17,\"./time\":22}],13:[function(require,module,exports){\nvar util_1 = require('../util');\r\nvar type_1 = require('../type');\r\nvar channel_1 = require('../channel');\r\nvar time = require('./time');\r\nfunction compileAxis(channel, model) {\r\n    var isCol = channel === channel_1.COLUMN, isRow = channel === channel_1.ROW, type = isCol ? 'x' : isRow ? 'y' : channel;\r\n    var def = {\r\n        type: type,\r\n        scale: channel\r\n    };\r\n    [\r\n        'format', 'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'title',\r\n        'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'tickSizeEnd',\r\n        'titleOffset', 'values', 'subdivide'\r\n    ].forEach(function (property) {\r\n        var method;\r\n        var value = (method = exports[property]) ?\r\n            method(model, channel, def) :\r\n            model.fieldDef(channel).axis[property];\r\n        if (value !== undefined) {\r\n            def[property] = value;\r\n        }\r\n    });\r\n    var props = model.fieldDef(channel).axis.properties || {};\r\n    [\r\n        'axis', 'labels',\r\n        'grid', 'title', 'ticks', 'majorTicks', 'minorTicks'\r\n    ].forEach(function (group) {\r\n        var value = properties[group] ?\r\n            properties[group](model, channel, props[group], def) :\r\n            props[group];\r\n        if (value !== undefined) {\r\n            def.properties = def.properties || {};\r\n            def.properties[group] = value;\r\n        }\r\n    });\r\n    return def;\r\n}\r\nexports.compileAxis = compileAxis;\r\nfunction format(model, channel) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    var format = fieldDef.axis.format;\r\n    if (format !== undefined) {\r\n        return format;\r\n    }\r\n    if (fieldDef.type === type_1.QUANTITATIVE) {\r\n        return model.numberFormat(channel);\r\n    }\r\n    else if (fieldDef.type === type_1.TEMPORAL) {\r\n        var timeUnit = fieldDef.timeUnit;\r\n        if (!timeUnit) {\r\n            return model.config('timeFormat');\r\n        }\r\n        else if (timeUnit === 'year') {\r\n            return 'd';\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nexports.format = format;\r\nfunction grid(model, channel) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    var grid = fieldDef.axis.grid;\r\n    if (grid !== undefined) {\r\n        return grid;\r\n    }\r\n    return !model.isOrdinalScale(channel) && !fieldDef.bin;\r\n}\r\nexports.grid = grid;\r\nfunction layer(model, channel, def) {\r\n    var layer = model.fieldDef(channel).axis.layer;\r\n    if (layer !== undefined) {\r\n        return layer;\r\n    }\r\n    if (def.grid) {\r\n        return 'back';\r\n    }\r\n    return undefined;\r\n}\r\nexports.layer = layer;\r\n;\r\nfunction offset(model, channel, def) {\r\n    var offset = model.fieldDef(channel).axis.offset;\r\n    if (offset) {\r\n        return offset;\r\n    }\r\n    if ((channel === channel_1.ROW && !model.has(channel_1.Y)) ||\r\n        (channel === channel_1.COLUMN && !model.has(channel_1.X))) {\r\n        return model.config('cell').gridOffset;\r\n    }\r\n    return undefined;\r\n}\r\nexports.offset = offset;\r\nfunction orient(model, channel) {\r\n    var orient = model.fieldDef(channel).axis.orient;\r\n    if (orient) {\r\n        return orient;\r\n    }\r\n    else if (channel === channel_1.COLUMN) {\r\n        return 'top';\r\n    }\r\n    else if (channel === channel_1.ROW) {\r\n        if (model.has(channel_1.Y) && model.fieldDef(channel_1.Y).axis.orient !== 'right') {\r\n            return 'right';\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nexports.orient = orient;\r\nfunction ticks(model, channel) {\r\n    var ticks = model.fieldDef(channel).axis.ticks;\r\n    if (ticks !== undefined) {\r\n        return ticks;\r\n    }\r\n    if (channel === channel_1.X && !model.fieldDef(channel).bin) {\r\n        return 5;\r\n    }\r\n    return undefined;\r\n}\r\nexports.ticks = ticks;\r\nfunction tickSize(model, channel) {\r\n    var tickSize = model.fieldDef(channel).axis.tickSize;\r\n    if (tickSize !== undefined) {\r\n        return tickSize;\r\n    }\r\n    if (channel === channel_1.ROW || channel === channel_1.COLUMN) {\r\n        return 0;\r\n    }\r\n    return undefined;\r\n}\r\nexports.tickSize = tickSize;\r\nfunction title(model, channel) {\r\n    var axisSpec = model.fieldDef(channel).axis;\r\n    if (axisSpec.title !== undefined) {\r\n        return axisSpec.title;\r\n    }\r\n    var fieldTitle = model.fieldTitle(channel);\r\n    var layout = model.layout();\r\n    var maxLength;\r\n    if (axisSpec.titleMaxLength) {\r\n        maxLength = axisSpec.titleMaxLength;\r\n    }\r\n    else if (channel === channel_1.X && typeof layout.cellWidth === 'number') {\r\n        maxLength = layout.cellWidth / model.config('characterWidth');\r\n    }\r\n    else if (channel === channel_1.Y && typeof layout.cellHeight === 'number') {\r\n        maxLength = layout.cellHeight / model.config('characterWidth');\r\n    }\r\n    return maxLength ? util_1.truncate(fieldTitle, maxLength) : fieldTitle;\r\n}\r\nexports.title = title;\r\nvar properties;\r\n(function (properties) {\r\n    function axis(model, channel, spec) {\r\n        if (channel === channel_1.ROW || channel === channel_1.COLUMN) {\r\n            return util_1.extend({\r\n                opacity: { value: 0 }\r\n            }, spec || {});\r\n        }\r\n        return spec || undefined;\r\n    }\r\n    properties.axis = axis;\r\n    function labels(model, channel, spec, def) {\r\n        var fieldDef = model.fieldDef(channel);\r\n        var filterName = time.labelTemplate(fieldDef.timeUnit, fieldDef.axis.shortTimeNames);\r\n        if (fieldDef.type === type_1.TEMPORAL && filterName) {\r\n            spec = util_1.extend({\r\n                text: { template: '{{datum.data | ' + filterName + '}}' }\r\n            }, spec || {});\r\n        }\r\n        if (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) && fieldDef.axis.labelMaxLength) {\r\n            spec = util_1.extend({\r\n                text: {\r\n                    template: '{{ datum.data | truncate:' + fieldDef.axis.labelMaxLength + '}}'\r\n                }\r\n            }, spec || {});\r\n        }\r\n        switch (channel) {\r\n            case channel_1.X:\r\n                if (model.isDimension(channel_1.X) || fieldDef.type === type_1.TEMPORAL) {\r\n                    spec = util_1.extend({\r\n                        angle: { value: 270 },\r\n                        align: { value: def.orient === 'top' ? 'left' : 'right' },\r\n                        baseline: { value: 'middle' }\r\n                    }, spec || {});\r\n                }\r\n                break;\r\n            case channel_1.ROW:\r\n                if (def.orient === 'right') {\r\n                    spec = util_1.extend({\r\n                        angle: { value: 90 },\r\n                        align: { value: 'center' },\r\n                        baseline: { value: 'bottom' }\r\n                    }, spec || {});\r\n                }\r\n        }\r\n        return spec || undefined;\r\n    }\r\n    properties.labels = labels;\r\n})(properties || (properties = {}));\r\n},{\"../channel\":11,\"../type\":42,\"../util\":43,\"./time\":22}],14:[function(require,module,exports){\nvar Model_1 = require('./Model');\r\nvar axis_1 = require('./axis');\r\nvar data_1 = require('./data');\r\nvar facet_1 = require('./facet');\r\nvar legend_1 = require('./legend');\r\nvar marks_1 = require('./marks');\r\nvar scale_1 = require('./scale');\r\nvar util_1 = require('../util');\r\nvar data_2 = require('../data');\r\nvar channel_1 = require('../channel');\r\nvar Model_2 = require('./Model');\r\nexports.Model = Model_2.Model;\r\nfunction compile(spec, theme) {\r\n    var model = new Model_1.Model(spec, theme);\r\n    var layout = model.layout();\r\n    var rootGroup = {\r\n        name: 'root',\r\n        type: 'group',\r\n        from: { data: data_2.LAYOUT },\r\n        properties: {\r\n            update: {\r\n                width: layout.width.field ?\r\n                    { field: layout.width.field } :\r\n                    { value: layout.width },\r\n                height: layout.height.field ?\r\n                    { field: layout.height.field } :\r\n                    { value: layout.height }\r\n            }\r\n        }\r\n    };\r\n    var marks = marks_1.compileMarks(model);\r\n    if (model.has(channel_1.ROW) || model.has(channel_1.COLUMN)) {\r\n        util_1.extend(rootGroup, facet_1.facetMixins(model, marks));\r\n    }\r\n    else {\r\n        rootGroup.marks = marks.map(function (marks) {\r\n            marks.from = marks.from || {};\r\n            marks.from.data = model.dataTable();\r\n            return marks;\r\n        });\r\n        var scaleNames = model.map(function (_, channel) {\r\n            return channel;\r\n        });\r\n        rootGroup.scales = scale_1.compileScales(scaleNames, model);\r\n        var axes = (model.has(channel_1.X) ? [axis_1.compileAxis(channel_1.X, model)] : [])\r\n            .concat(model.has(channel_1.Y) ? [axis_1.compileAxis(channel_1.Y, model)] : []);\r\n        if (axes.length > 0) {\r\n            rootGroup.axes = axes;\r\n        }\r\n    }\r\n    var legends = legend_1.compileLegends(model);\r\n    if (legends.length > 0) {\r\n        rootGroup.legends = legends;\r\n    }\r\n    var FIT = 1;\r\n    var output = {\r\n        width: layout.width.field ? FIT : layout.width,\r\n        height: layout.height.field ? FIT : layout.height,\r\n        padding: 'auto',\r\n        data: data_1.compileData(model),\r\n        marks: [rootGroup]\r\n    };\r\n    return {\r\n        spec: output\r\n    };\r\n}\r\nexports.compile = compile;\r\n},{\"../channel\":11,\"../data\":23,\"../util\":43,\"./Model\":12,\"./axis\":13,\"./data\":15,\"./facet\":16,\"./legend\":18,\"./marks\":19,\"./scale\":20}],15:[function(require,module,exports){\nvar vlFieldDef = require('../fielddef');\r\nvar util = require('../util');\r\nvar bin_1 = require('../bin');\r\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nvar time = require('./time');\r\nvar type_1 = require('../type');\r\nfunction compileData(model) {\r\n    var def = [source.def(model)];\r\n    var summaryDef = summary.def(model);\r\n    if (summaryDef) {\r\n        def.push(summaryDef);\r\n    }\r\n    filterNonPositiveForLog(def[def.length - 1], model);\r\n    var statsDef = layout.def(model);\r\n    if (statsDef) {\r\n        def.push(statsDef);\r\n    }\r\n    var stackDef = model.stack();\r\n    if (stackDef) {\r\n        def.push(stack.def(model, stackDef));\r\n    }\r\n    return def;\r\n}\r\nexports.compileData = compileData;\r\nvar source;\r\n(function (source_1) {\r\n    function def(model) {\r\n        var source = { name: data_1.SOURCE };\r\n        if (model.hasValues()) {\r\n            source.values = model.data().values;\r\n            source.format = { type: 'json' };\r\n        }\r\n        else {\r\n            source.url = model.data().url;\r\n            source.format = { type: model.data().formatType };\r\n        }\r\n        var parse = formatParse(model);\r\n        if (parse) {\r\n            source.format.parse = parse;\r\n        }\r\n        source.transform = transform(model);\r\n        return source;\r\n    }\r\n    source_1.def = def;\r\n    function formatParse(model) {\r\n        var parse;\r\n        model.forEach(function (fieldDef) {\r\n            if (fieldDef.type === type_1.TEMPORAL) {\r\n                parse = parse || {};\r\n                parse[fieldDef.field] = 'date';\r\n            }\r\n            else if (fieldDef.type === type_1.QUANTITATIVE) {\r\n                if (vlFieldDef.isCount(fieldDef))\r\n                    return;\r\n                parse = parse || {};\r\n                parse[fieldDef.field] = 'number';\r\n            }\r\n        });\r\n        return parse;\r\n    }\r\n    function transform(model) {\r\n        return nullFilterTransform(model).concat(formulaTransform(model), timeTransform(model), binTransform(model), filterTransform(model));\r\n    }\r\n    source_1.transform = transform;\r\n    function timeTransform(model) {\r\n        return model.reduce(function (transform, fieldDef, channel) {\r\n            if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {\r\n                var field = model.field(channel, { nofn: true, datum: true });\r\n                transform.push({\r\n                    type: 'formula',\r\n                    field: model.field(channel),\r\n                    expr: time.formula(fieldDef.timeUnit, field)\r\n                });\r\n            }\r\n            return transform;\r\n        }, []);\r\n    }\r\n    source_1.timeTransform = timeTransform;\r\n    function binTransform(model) {\r\n        return model.reduce(function (transform, fieldDef, channel) {\r\n            var bin = model.bin(channel);\r\n            if (bin) {\r\n                transform.push({\r\n                    type: 'bin',\r\n                    field: fieldDef.field,\r\n                    output: {\r\n                        start: model.field(channel, { binSuffix: '_start' }),\r\n                        mid: model.field(channel, { binSuffix: '_mid' }),\r\n                        end: model.field(channel, { binSuffix: '_end' })\r\n                    },\r\n                    maxbins: typeof bin === 'boolean' ? bin_1.MAXBINS_DEFAULT : bin.maxbins\r\n                });\r\n            }\r\n            return transform;\r\n        }, []);\r\n    }\r\n    source_1.binTransform = binTransform;\r\n    function nullFilterTransform(model) {\r\n        var filterNull = model.config('filterNull');\r\n        var filteredFields = util.keys(model.reduce(function (filteredFields, fieldDef) {\r\n            if (fieldDef.field && fieldDef.field !== '*' && filterNull[fieldDef.type]) {\r\n                filteredFields[fieldDef.field] = true;\r\n            }\r\n            return filteredFields;\r\n        }, {}));\r\n        return filteredFields.length > 0 ?\r\n            [{\r\n                    type: 'filter',\r\n                    test: filteredFields.map(function (fieldName) {\r\n                        return 'datum.' + fieldName + '!==null';\r\n                    }).join(' && ')\r\n                }] : [];\r\n    }\r\n    source_1.nullFilterTransform = nullFilterTransform;\r\n    function filterTransform(model) {\r\n        var filter = model.data().filter;\r\n        return filter ? [{\r\n                type: 'filter',\r\n                test: filter\r\n            }] : [];\r\n    }\r\n    source_1.filterTransform = filterTransform;\r\n    function formulaTransform(model) {\r\n        var calculate = model.data().calculate;\r\n        if (calculate === undefined) {\r\n            return [];\r\n        }\r\n        return calculate.reduce(function (transform, formula) {\r\n            transform.push(util.extend({ type: 'formula' }, formula));\r\n            return transform;\r\n        }, []);\r\n    }\r\n    source_1.formulaTransform = formulaTransform;\r\n})(source = exports.source || (exports.source = {}));\r\nvar layout;\r\n(function (layout_1) {\r\n    function def(model) {\r\n        var summarize = [];\r\n        var formulas = [];\r\n        if (model.has(channel_1.X) && model.isOrdinalScale(channel_1.X)) {\r\n            summarize.push({\r\n                field: model.field(channel_1.X),\r\n                ops: ['distinct']\r\n            });\r\n            var xScale = model.fieldDef(channel_1.X).scale;\r\n            formulas.push({\r\n                type: 'formula',\r\n                field: 'cellWidth',\r\n                expr: '(' + model.field(channel_1.X, { datum: true, prefn: 'distinct_' }) + ' + ' +\r\n                    xScale.padding + ') * ' + xScale.bandWidth\r\n            });\r\n        }\r\n        if (model.has(channel_1.Y) && model.isOrdinalScale(channel_1.Y)) {\r\n            summarize.push({\r\n                field: model.field(channel_1.Y),\r\n                ops: ['distinct']\r\n            });\r\n            var yScale = model.fieldDef(channel_1.Y).scale;\r\n            formulas.push({\r\n                type: 'formula',\r\n                field: 'cellHeight',\r\n                expr: '(' + model.field(channel_1.Y, { datum: true, prefn: 'distinct_' }) + ' + ' +\r\n                    yScale.padding + ') * ' + yScale.bandWidth\r\n            });\r\n        }\r\n        var cellPadding = model.config('cell').padding;\r\n        var layout = model.layout();\r\n        if (model.has(channel_1.COLUMN)) {\r\n            var cellWidth = layout.cellWidth.field ?\r\n                'datum.' + layout.cellWidth.field :\r\n                layout.cellWidth;\r\n            var distinctCol = model.field(channel_1.COLUMN, { datum: true, prefn: 'distinct_' });\r\n            summarize.push({\r\n                field: model.fieldDef(channel_1.COLUMN).field,\r\n                ops: ['distinct']\r\n            });\r\n            formulas.push({\r\n                type: 'formula',\r\n                field: 'width',\r\n                expr: cellWidth + ' * ' + distinctCol + ' + ' +\r\n                    '(' + distinctCol + ' - 1) * ' + cellPadding\r\n            });\r\n        }\r\n        if (model.has(channel_1.ROW)) {\r\n            var cellHeight = layout.cellHeight.field ?\r\n                'datum.' + layout.cellHeight.field :\r\n                layout.cellHeight;\r\n            var distinctRow = model.field(channel_1.ROW, { datum: true, prefn: 'distinct_' });\r\n            summarize.push({\r\n                field: model.fieldDef(channel_1.ROW).field,\r\n                ops: ['distinct']\r\n            });\r\n            formulas.push({\r\n                type: 'formula',\r\n                field: 'height',\r\n                expr: cellHeight + ' * ' + distinctRow + ' + ' +\r\n                    '(' + distinctRow + ' - 1) * ' + cellPadding\r\n            });\r\n        }\r\n        if (summarize.length > 0) {\r\n            return {\r\n                name: data_1.LAYOUT,\r\n                source: model.dataTable(),\r\n                transform: [{\r\n                        type: 'aggregate',\r\n                        summarize: summarize\r\n                    }].concat(formulas)\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    layout_1.def = def;\r\n})(layout = exports.layout || (exports.layout = {}));\r\nvar summary;\r\n(function (summary) {\r\n    function def(model) {\r\n        var dims = {};\r\n        var meas = {};\r\n        var hasAggregate = false;\r\n        model.forEach(function (fieldDef, channel) {\r\n            if (fieldDef.aggregate) {\r\n                hasAggregate = true;\r\n                if (fieldDef.aggregate === 'count') {\r\n                    meas['*'] = meas['*'] || {};\r\n                    meas['*'].count = true;\r\n                }\r\n                else {\r\n                    meas[fieldDef.field] = meas[fieldDef.field] || {};\r\n                    meas[fieldDef.field][fieldDef.aggregate] = true;\r\n                }\r\n            }\r\n            else {\r\n                if (fieldDef.bin) {\r\n                    dims[model.field(channel, { binSuffix: '_start' })] = model.field(channel, { binSuffix: '_start' });\r\n                    dims[model.field(channel, { binSuffix: '_mid' })] = model.field(channel, { binSuffix: '_mid' });\r\n                    dims[model.field(channel, { binSuffix: '_end' })] = model.field(channel, { binSuffix: '_end' });\r\n                }\r\n                else {\r\n                    dims[fieldDef.field] = model.field(channel);\r\n                }\r\n            }\r\n        });\r\n        var groupby = util.vals(dims);\r\n        var summarize = util.reduce(meas, function (summarize, fnDictSet, field) {\r\n            summarize[field] = util.keys(fnDictSet);\r\n            return summarize;\r\n        }, {});\r\n        if (hasAggregate) {\r\n            return {\r\n                name: data_1.SUMMARY,\r\n                source: data_1.SOURCE,\r\n                transform: [{\r\n                        type: 'aggregate',\r\n                        groupby: groupby,\r\n                        summarize: summarize\r\n                    }]\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    summary.def = def;\r\n    ;\r\n})(summary = exports.summary || (exports.summary = {}));\r\nvar stack;\r\n(function (stack) {\r\n    function def(model, stackProps) {\r\n        var groupbyChannel = stackProps.groupbyChannel;\r\n        var fieldChannel = stackProps.fieldChannel;\r\n        var facetFields = (model.has(channel_1.COLUMN) ? [model.field(channel_1.COLUMN)] : [])\r\n            .concat((model.has(channel_1.ROW) ? [model.field(channel_1.ROW)] : []));\r\n        var stacked = {\r\n            name: data_1.STACKED,\r\n            source: model.dataTable(),\r\n            transform: [{\r\n                    type: 'aggregate',\r\n                    groupby: [model.field(groupbyChannel)].concat(facetFields),\r\n                    summarize: [{ ops: ['sum'], field: model.field(fieldChannel) }]\r\n                }]\r\n        };\r\n        if (facetFields && facetFields.length > 0) {\r\n            stacked.transform.push({\r\n                type: 'aggregate',\r\n                groupby: facetFields,\r\n                summarize: [{\r\n                        ops: ['max'],\r\n                        field: model.field(fieldChannel, { prefn: 'sum_' })\r\n                    }]\r\n            });\r\n        }\r\n        return stacked;\r\n    }\r\n    stack.def = def;\r\n    ;\r\n})(stack = exports.stack || (exports.stack = {}));\r\nfunction filterNonPositiveForLog(dataTable, model) {\r\n    model.forEach(function (_, channel) {\r\n        if (model.fieldDef(channel).scale.type === 'log') {\r\n            dataTable.transform.push({\r\n                type: 'filter',\r\n                test: model.field(channel, { datum: true }) + ' > 0'\r\n            });\r\n        }\r\n    });\r\n}\r\nexports.filterNonPositiveForLog = filterNonPositiveForLog;\r\n},{\"../bin\":10,\"../channel\":11,\"../data\":23,\"../fielddef\":25,\"../type\":42,\"../util\":43,\"./time\":22}],16:[function(require,module,exports){\nvar util = require('../util');\r\nvar channel_1 = require('../channel');\r\nvar axis_1 = require('./axis');\r\nvar scale_1 = require('./scale');\r\nfunction facetMixins(model, marks) {\r\n    var layout = model.layout();\r\n    var cellWidth = !model.has(channel_1.COLUMN) ?\r\n        { field: { group: 'width' } } :\r\n        layout.cellWidth.field ?\r\n            { scale: 'column', band: true } :\r\n            { value: layout.cellWidth };\r\n    var cellHeight = !model.has(channel_1.ROW) ?\r\n        { field: { group: 'height' } } :\r\n        layout.cellHeight.field ?\r\n            { scale: 'row', band: true } :\r\n            { value: layout.cellHeight };\r\n    var facetGroupProperties = {\r\n        width: cellWidth,\r\n        height: cellHeight\r\n    };\r\n    var cellConfig = model.config('cell');\r\n    ['fill', 'fillOpacity', 'stroke', 'strokeWidth',\r\n        'strokeOpacity', 'strokeDash', 'strokeDashOffset']\r\n        .forEach(function (property) {\r\n        var value = cellConfig[property];\r\n        if (value !== undefined) {\r\n            facetGroupProperties[property] = value;\r\n        }\r\n    });\r\n    var rootMarks = [], rootAxes = [], facetKeys = [], cellAxes = [];\r\n    var hasRow = model.has(channel_1.ROW), hasCol = model.has(channel_1.COLUMN);\r\n    if (hasRow) {\r\n        if (!model.isDimension(channel_1.ROW)) {\r\n            util.error('Row encoding should be ordinal.');\r\n        }\r\n        facetGroupProperties.y = {\r\n            scale: channel_1.ROW,\r\n            field: model.field(channel_1.ROW)\r\n        };\r\n        facetKeys.push(model.field(channel_1.ROW));\r\n        rootAxes.push(axis_1.compileAxis(channel_1.ROW, model));\r\n        if (model.has(channel_1.X)) {\r\n            rootMarks.push(getXAxesGroup(model, cellWidth, hasCol));\r\n        }\r\n        rootMarks.push(getRowRulesGroup(model, cellHeight));\r\n    }\r\n    else {\r\n        if (model.has(channel_1.X)) {\r\n            cellAxes.push(axis_1.compileAxis(channel_1.X, model));\r\n        }\r\n    }\r\n    if (hasCol) {\r\n        if (!model.isDimension(channel_1.COLUMN)) {\r\n            util.error('Col encoding should be ordinal.');\r\n        }\r\n        facetGroupProperties.x = {\r\n            scale: channel_1.COLUMN,\r\n            field: model.field(channel_1.COLUMN)\r\n        };\r\n        facetKeys.push(model.field(channel_1.COLUMN));\r\n        rootAxes.push(axis_1.compileAxis(channel_1.COLUMN, model));\r\n        if (model.has(channel_1.Y)) {\r\n            rootMarks.push(getYAxesGroup(model, cellHeight, hasRow));\r\n        }\r\n        rootMarks.push(getColumnRulesGroup(model, cellWidth));\r\n    }\r\n    else {\r\n        if (model.has(channel_1.Y)) {\r\n            cellAxes.push(axis_1.compileAxis(channel_1.Y, model));\r\n        }\r\n    }\r\n    var facetGroup = {\r\n        name: 'cell',\r\n        type: 'group',\r\n        from: {\r\n            data: model.dataTable(),\r\n            transform: [{ type: 'facet', groupby: facetKeys }]\r\n        },\r\n        properties: {\r\n            update: facetGroupProperties\r\n        },\r\n        marks: marks\r\n    };\r\n    if (cellAxes.length > 0) {\r\n        facetGroup.axes = cellAxes;\r\n    }\r\n    rootMarks.push(facetGroup);\r\n    var scaleNames = model.map(function (_, channel) {\r\n        return channel;\r\n    });\r\n    return {\r\n        marks: rootMarks,\r\n        axes: rootAxes,\r\n        scales: scale_1.compileScales(scaleNames, model)\r\n    };\r\n}\r\nexports.facetMixins = facetMixins;\r\nfunction getXAxesGroup(model, cellWidth, hasCol) {\r\n    var xAxesGroup = {\r\n        name: 'x-axes',\r\n        type: 'group',\r\n        properties: {\r\n            update: {\r\n                width: cellWidth,\r\n                height: { field: { group: 'height' } },\r\n                x: hasCol ? { scale: channel_1.COLUMN, field: model.field(channel_1.COLUMN) } : { value: 0 },\r\n                y: { value: -model.config('cell').padding / 2 }\r\n            }\r\n        },\r\n        axes: [axis_1.compileAxis(channel_1.X, model)]\r\n    };\r\n    if (hasCol) {\r\n        xAxesGroup.from = {\r\n            data: model.dataTable(),\r\n            transform: { type: 'facet', groupby: [model.field(channel_1.COLUMN)] }\r\n        };\r\n    }\r\n    return xAxesGroup;\r\n}\r\nfunction getYAxesGroup(model, cellHeight, hasRow) {\r\n    var yAxesGroup = {\r\n        name: 'y-axes',\r\n        type: 'group',\r\n        properties: {\r\n            update: {\r\n                width: { field: { group: 'width' } },\r\n                height: cellHeight,\r\n                x: { value: -model.config('cell').padding / 2 },\r\n                y: hasRow ? { scale: channel_1.ROW, field: model.field(channel_1.ROW) } : { value: 0 }\r\n            }\r\n        },\r\n        axes: [axis_1.compileAxis(channel_1.Y, model)]\r\n    };\r\n    if (hasRow) {\r\n        yAxesGroup.from = {\r\n            data: model.dataTable(),\r\n            transform: { type: 'facet', groupby: [model.field(channel_1.ROW)] }\r\n        };\r\n    }\r\n    return yAxesGroup;\r\n}\r\nfunction getRowRulesGroup(model, cellHeight) {\r\n    var rowRulesOnTop = !model.has(channel_1.X) || model.fieldDef(channel_1.X).axis.orient !== 'top';\r\n    var offset = model.config('cell').padding / 2 - 1;\r\n    var rowRules = {\r\n        name: 'row-rules',\r\n        type: 'rule',\r\n        from: {\r\n            data: model.dataTable(),\r\n            transform: [{ type: 'facet', groupby: [model.field(channel_1.ROW)] }]\r\n        },\r\n        properties: {\r\n            update: {\r\n                y: {\r\n                    scale: 'row',\r\n                    field: model.field(channel_1.ROW),\r\n                    offset: (rowRulesOnTop ? -1 : 1) * offset\r\n                },\r\n                x: { value: 0, offset: -model.config('cell').gridOffset },\r\n                x2: { field: { group: 'width' }, offset: model.config('cell').gridOffset },\r\n                stroke: { value: model.config('cell').gridColor },\r\n                strokeOpacity: { value: model.config('cell').gridOpacity }\r\n            }\r\n        }\r\n    };\r\n    if (rowRulesOnTop) {\r\n        return rowRules;\r\n    }\r\n    return {\r\n        name: 'row-rules-group',\r\n        type: 'group',\r\n        properties: {\r\n            update: {\r\n                y: cellHeight.value ?\r\n                    cellHeight :\r\n                    { field: { parent: 'cellHeight' } },\r\n                width: { field: { group: 'width' } }\r\n            }\r\n        },\r\n        marks: [rowRules]\r\n    };\r\n}\r\nfunction getColumnRulesGroup(model, cellWidth) {\r\n    var colRulesOnLeft = !model.has(channel_1.Y) || model.fieldDef(channel_1.Y).axis.orient === 'right';\r\n    var offset = model.config('cell').padding / 2 - 1;\r\n    var columnRules = {\r\n        name: 'column-rules',\r\n        type: 'rule',\r\n        from: {\r\n            data: model.dataTable(),\r\n            transform: [{ type: 'facet', groupby: [model.field(channel_1.COLUMN)] }]\r\n        },\r\n        properties: {\r\n            update: {\r\n                x: {\r\n                    scale: 'column',\r\n                    field: model.field(channel_1.COLUMN),\r\n                    offset: (colRulesOnLeft ? -1 : 1) * offset\r\n                },\r\n                y: { value: 0, offset: -model.config('cell').gridOffset },\r\n                y2: { field: { group: 'height' }, offset: model.config('cell').gridOffset },\r\n                stroke: { value: model.config('cell').gridColor },\r\n                strokeOpacity: { value: model.config('cell').gridOpacity }\r\n            }\r\n        }\r\n    };\r\n    if (colRulesOnLeft) {\r\n        return columnRules;\r\n    }\r\n    return {\r\n        name: 'column-rules-group',\r\n        type: 'group',\r\n        properties: {\r\n            update: {\r\n                x: cellWidth.value ?\r\n                    cellWidth :\r\n                    { field: { parent: 'cellWidth' } },\r\n                height: { field: { group: 'height' } }\r\n            }\r\n        },\r\n        marks: [columnRules]\r\n    };\r\n}\r\n},{\"../channel\":11,\"../util\":43,\"./axis\":13,\"./scale\":20}],17:[function(require,module,exports){\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nfunction compileLayout(model) {\r\n    var cellWidth = getCellWidth(model);\r\n    var cellHeight = getCellHeight(model);\r\n    return {\r\n        cellWidth: cellWidth,\r\n        cellHeight: cellHeight,\r\n        width: getWidth(model, cellWidth),\r\n        height: getHeight(model, cellHeight)\r\n    };\r\n}\r\nexports.compileLayout = compileLayout;\r\nfunction getCellWidth(model) {\r\n    if (model.has(channel_1.X)) {\r\n        if (model.isOrdinalScale(channel_1.X)) {\r\n            return { data: data_1.LAYOUT, field: 'cellWidth' };\r\n        }\r\n        return model.config('cell').width;\r\n    }\r\n    if (model.marktype() === channel_1.TEXT) {\r\n        return model.config('textCellWidth');\r\n    }\r\n    return model.fieldDef(channel_1.X).scale.bandWidth;\r\n}\r\nfunction getWidth(model, cellWidth) {\r\n    if (model.has(channel_1.COLUMN)) {\r\n        return { data: data_1.LAYOUT, field: 'width' };\r\n    }\r\n    return cellWidth;\r\n}\r\nfunction getCellHeight(model) {\r\n    if (model.has(channel_1.Y)) {\r\n        if (model.isOrdinalScale(channel_1.Y)) {\r\n            return { data: data_1.LAYOUT, field: 'cellHeight' };\r\n        }\r\n        else {\r\n            return model.config('cell').height;\r\n        }\r\n    }\r\n    return model.fieldDef(channel_1.Y).scale.bandWidth;\r\n}\r\nfunction getHeight(model, cellHeight) {\r\n    if (model.has(channel_1.ROW)) {\r\n        return { data: data_1.LAYOUT, field: 'height' };\r\n    }\r\n    return cellHeight;\r\n}\r\n},{\"../channel\":11,\"../data\":23}],18:[function(require,module,exports){\nvar util_1 = require('../util');\r\nvar channel_1 = require('../channel');\r\nvar time = require('./time');\r\nvar type_1 = require('../type');\r\nfunction compileLegends(model) {\r\n    var defs = [];\r\n    if (model.has(channel_1.COLOR) && model.fieldDef(channel_1.COLOR).legend) {\r\n        defs.push(compileLegend(model, channel_1.COLOR, {\r\n            fill: channel_1.COLOR\r\n        }));\r\n    }\r\n    if (model.has(channel_1.SIZE) && model.fieldDef(channel_1.SIZE).legend) {\r\n        defs.push(compileLegend(model, channel_1.SIZE, {\r\n            size: channel_1.SIZE\r\n        }));\r\n    }\r\n    if (model.has(channel_1.SHAPE) && model.fieldDef(channel_1.SHAPE).legend) {\r\n        defs.push(compileLegend(model, channel_1.SHAPE, {\r\n            shape: channel_1.SHAPE\r\n        }));\r\n    }\r\n    return defs;\r\n}\r\nexports.compileLegends = compileLegends;\r\nfunction compileLegend(model, channel, def) {\r\n    var legend = model.fieldDef(channel).legend;\r\n    def.title = title(model, channel);\r\n    ['orient', 'format', 'values'].forEach(function (property) {\r\n        var value = legend[property];\r\n        if (value !== undefined) {\r\n            def[property] = value;\r\n        }\r\n    });\r\n    var props = (typeof legend !== 'boolean' && legend.properties) || {};\r\n    ['title', 'labels', 'symbols', 'legend'].forEach(function (group) {\r\n        var value = properties[group] ?\r\n            properties[group](model, channel, props[group]) :\r\n            props[group];\r\n        if (value !== undefined) {\r\n            def.properties = def.properties || {};\r\n            def.properties[group] = value;\r\n        }\r\n    });\r\n    return def;\r\n}\r\nexports.compileLegend = compileLegend;\r\nfunction title(model, channel) {\r\n    var legend = model.fieldDef(channel).legend;\r\n    if (typeof legend !== 'boolean' && legend.title) {\r\n        return legend.title;\r\n    }\r\n    return model.fieldTitle(channel);\r\n}\r\nexports.title = title;\r\nvar properties;\r\n(function (properties) {\r\n    function labels(model, channel, spec) {\r\n        var fieldDef = model.fieldDef(channel);\r\n        var timeUnit = fieldDef.timeUnit;\r\n        if (fieldDef.type === type_1.TEMPORAL && timeUnit && time.labelTemplate(timeUnit)) {\r\n            return util_1.extend({\r\n                text: {\r\n                    template: '{{datum.data | ' + time.labelTemplate(timeUnit) + '}}'\r\n                }\r\n            }, spec || {});\r\n        }\r\n        return spec;\r\n    }\r\n    properties.labels = labels;\r\n    function symbols(model, channel, spec) {\r\n        var symbols = {};\r\n        var marktype = model.marktype();\r\n        switch (marktype) {\r\n            case 'bar':\r\n            case 'tick':\r\n            case 'text':\r\n                symbols.stroke = { value: 'transparent' };\r\n                symbols.shape = { value: 'square' };\r\n                break;\r\n            case 'circle':\r\n            case 'square':\r\n                symbols.shape = { value: marktype };\r\n            case 'point':\r\n                if (model.config('marks').filled) {\r\n                    if (model.has(channel_1.COLOR) && channel === channel_1.COLOR) {\r\n                        symbols.fill = { scale: channel_1.COLOR, field: 'data' };\r\n                    }\r\n                    else {\r\n                        symbols.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n                    }\r\n                    symbols.stroke = { value: 'transparent' };\r\n                }\r\n                else {\r\n                    if (model.has(channel_1.COLOR) && channel === channel_1.COLOR) {\r\n                        symbols.stroke = { scale: channel_1.COLOR, field: 'data' };\r\n                    }\r\n                    else {\r\n                        symbols.stroke = { value: model.fieldDef(channel_1.COLOR).value };\r\n                    }\r\n                    symbols.fill = { value: 'transparent' };\r\n                    symbols.strokeWidth = { value: model.config('marks').strokeWidth };\r\n                }\r\n                break;\r\n            case 'line':\r\n            case 'area':\r\n                break;\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity) {\r\n            symbols.opacity = { value: opacity };\r\n        }\r\n        symbols = util_1.extend(symbols, spec || {});\r\n        return util_1.keys(symbols).length > 0 ? symbols : undefined;\r\n    }\r\n    properties.symbols = symbols;\r\n})(properties || (properties = {}));\r\n},{\"../channel\":11,\"../type\":42,\"../util\":43,\"./time\":22}],19:[function(require,module,exports){\nvar channel_1 = require('../channel');\r\nvar marktype_1 = require('../marktype');\r\nvar type_1 = require('../type');\r\nvar stack_1 = require('./stack');\r\nvar MARKTYPES_MAP = {\r\n    bar: 'rect',\r\n    tick: 'rect',\r\n    point: 'symbol',\r\n    line: 'line',\r\n    area: 'area',\r\n    text: 'text',\r\n    circle: 'symbol',\r\n    square: 'symbol'\r\n};\r\nfunction compileMarks(model) {\r\n    var marktype = model.marktype();\r\n    if (marktype === marktype_1.LINE || marktype === marktype_1.AREA) {\r\n        var sortBy = marktype === marktype_1.LINE ? model.config('sortLineBy') : undefined;\r\n        if (!sortBy) {\r\n            var sortField = (model.isMeasure(channel_1.X) && model.isDimension(channel_1.Y)) ? channel_1.Y : channel_1.X;\r\n            sortBy = '-' + model.field(sortField);\r\n        }\r\n        var pathMarks = {\r\n            type: MARKTYPES_MAP[marktype],\r\n            from: {\r\n                transform: [{ type: 'sort', by: sortBy }]\r\n            },\r\n            properties: {\r\n                update: properties[marktype](model)\r\n            }\r\n        };\r\n        var details = detailFields(model);\r\n        if (details.length > 0) {\r\n            var facetTransform = { type: 'facet', groupby: details };\r\n            var transform = marktype === marktype_1.AREA && model.stack() ?\r\n                [stack_1.imputeTransform(model), stack_1.stackTransform(model), facetTransform] :\r\n                [facetTransform];\r\n            return [{\r\n                    name: marktype + '-facet',\r\n                    type: 'group',\r\n                    from: {\r\n                        transform: transform\r\n                    },\r\n                    properties: {\r\n                        update: {\r\n                            width: { field: { group: 'width' } },\r\n                            height: { field: { group: 'height' } }\r\n                        }\r\n                    },\r\n                    marks: [pathMarks]\r\n                }];\r\n        }\r\n        else {\r\n            return [pathMarks];\r\n        }\r\n    }\r\n    else {\r\n        var marks = [];\r\n        if (marktype === marktype_1.TEXT && model.has(channel_1.COLOR)) {\r\n            marks.push({\r\n                type: 'rect',\r\n                properties: { update: properties.textBackground(model) }\r\n            });\r\n        }\r\n        var mainDef = {\r\n            type: MARKTYPES_MAP[marktype],\r\n            properties: {\r\n                update: properties[marktype](model)\r\n            }\r\n        };\r\n        var stack = model.stack();\r\n        if (marktype === marktype_1.BAR && stack) {\r\n            mainDef.from = {\r\n                transform: [stack_1.stackTransform(model)]\r\n            };\r\n        }\r\n        marks.push(mainDef);\r\n        return marks;\r\n    }\r\n}\r\nexports.compileMarks = compileMarks;\r\nfunction detailFields(model) {\r\n    return [channel_1.COLOR, channel_1.DETAIL, channel_1.SHAPE].reduce(function (details, channel) {\r\n        if (model.has(channel) && !model.fieldDef(channel).aggregate) {\r\n            details.push(model.field(channel));\r\n        }\r\n        return details;\r\n    }, []);\r\n}\r\nvar properties;\r\n(function (properties) {\r\n    function bar(model) {\r\n        var stack = model.stack();\r\n        var p = {};\r\n        if (stack && channel_1.X === stack.fieldChannel) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X) + '_start'\r\n            };\r\n            p.x2 = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X) + '_end'\r\n            };\r\n        }\r\n        else if (model.fieldDef(channel_1.X).bin) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_start' }),\r\n                offset: 1\r\n            };\r\n            p.x2 = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_end' })\r\n            };\r\n        }\r\n        else if (model.isMeasure(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X)\r\n            };\r\n            if (!model.has(channel_1.Y) || model.isDimension(channel_1.Y)) {\r\n                p.x2 = { value: 0 };\r\n            }\r\n        }\r\n        else {\r\n            if (model.has(channel_1.X)) {\r\n                p.xc = {\r\n                    scale: channel_1.X,\r\n                    field: model.field(channel_1.X)\r\n                };\r\n            }\r\n            else {\r\n                p.x = { value: 0, offset: model.config('singleBarOffset') };\r\n            }\r\n        }\r\n        if (!p.x2) {\r\n            if (!model.has(channel_1.X) || model.isOrdinalScale(channel_1.X)) {\r\n                if (model.has(channel_1.SIZE)) {\r\n                    p.width = {\r\n                        scale: channel_1.SIZE,\r\n                        field: model.field(channel_1.SIZE)\r\n                    };\r\n                }\r\n                else {\r\n                    p.width = {\r\n                        value: model.fieldDef(channel_1.X).scale.bandWidth,\r\n                        offset: -1\r\n                    };\r\n                }\r\n            }\r\n            else {\r\n                p.width = { value: 2 };\r\n            }\r\n        }\r\n        if (stack && channel_1.Y === stack.fieldChannel) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y) + '_start'\r\n            };\r\n            p.y2 = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y) + '_end'\r\n            };\r\n        }\r\n        else if (model.fieldDef(channel_1.Y).bin) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_start' })\r\n            };\r\n            p.y2 = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_end' }),\r\n                offset: 1\r\n            };\r\n        }\r\n        else if (model.isMeasure(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y)\r\n            };\r\n            p.y2 = { field: { group: 'height' } };\r\n        }\r\n        else {\r\n            if (model.has(channel_1.Y)) {\r\n                p.yc = {\r\n                    scale: channel_1.Y,\r\n                    field: model.field(channel_1.Y)\r\n                };\r\n            }\r\n            else {\r\n                p.y2 = {\r\n                    field: { group: 'height' },\r\n                    offset: -model.config('singleBarOffset')\r\n                };\r\n            }\r\n            if (model.has(channel_1.SIZE)) {\r\n                p.height = {\r\n                    scale: channel_1.SIZE,\r\n                    field: model.field(channel_1.SIZE)\r\n                };\r\n            }\r\n            else {\r\n                p.height = {\r\n                    value: model.fieldDef(channel_1.Y).scale.bandWidth,\r\n                    offset: -1\r\n                };\r\n            }\r\n        }\r\n        if (model.has(channel_1.COLOR)) {\r\n            p.fill = {\r\n                scale: channel_1.COLOR,\r\n                field: model.field(channel_1.COLOR)\r\n            };\r\n        }\r\n        else {\r\n            p.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity)\r\n            p.opacity = { value: opacity };\r\n        return p;\r\n    }\r\n    properties.bar = bar;\r\n    function point(model) {\r\n        var p = {};\r\n        var marksConfig = model.config('marks');\r\n        if (model.has(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.X)) {\r\n            p.x = { value: model.fieldDef(channel_1.X).scale.bandWidth / 2 };\r\n        }\r\n        if (model.has(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.Y)) {\r\n            p.y = { value: model.fieldDef(channel_1.Y).scale.bandWidth / 2 };\r\n        }\r\n        if (model.has(channel_1.SIZE)) {\r\n            p.size = {\r\n                scale: channel_1.SIZE,\r\n                field: model.field(channel_1.SIZE)\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.SIZE)) {\r\n            p.size = { value: model.fieldDef(channel_1.SIZE).value };\r\n        }\r\n        if (model.has(channel_1.SHAPE)) {\r\n            p.shape = {\r\n                scale: channel_1.SHAPE,\r\n                field: model.field(channel_1.SHAPE)\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.SHAPE)) {\r\n            p.shape = { value: model.fieldDef(channel_1.SHAPE).value };\r\n        }\r\n        if (marksConfig.filled) {\r\n            if (model.has(channel_1.COLOR)) {\r\n                p.fill = {\r\n                    scale: channel_1.COLOR,\r\n                    field: model.field(channel_1.COLOR)\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.COLOR)) {\r\n                p.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n            }\r\n        }\r\n        else {\r\n            if (model.has(channel_1.COLOR)) {\r\n                p.stroke = {\r\n                    scale: channel_1.COLOR,\r\n                    field: model.field(channel_1.COLOR)\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.COLOR)) {\r\n                p.stroke = { value: model.fieldDef(channel_1.COLOR).value };\r\n            }\r\n            p.strokeWidth = { value: model.config('marks').strokeWidth };\r\n        }\r\n        var opacity = marksConfig.opacity;\r\n        if (opacity) {\r\n            p.opacity = { value: opacity };\r\n        }\r\n        return p;\r\n    }\r\n    properties.point = point;\r\n    function line(model) {\r\n        var p = {};\r\n        if (model.has(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.X)) {\r\n            p.x = { value: 0 };\r\n        }\r\n        if (model.has(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.Y)) {\r\n            p.y = { field: { group: 'height' } };\r\n        }\r\n        if (model.has(channel_1.COLOR)) {\r\n            p.stroke = {\r\n                scale: channel_1.COLOR,\r\n                field: model.field(channel_1.COLOR)\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.COLOR)) {\r\n            p.stroke = { value: model.fieldDef(channel_1.COLOR).value };\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity)\r\n            p.opacity = { value: opacity };\r\n        p.strokeWidth = { value: model.config('marks').strokeWidth };\r\n        return p;\r\n    }\r\n    properties.line = line;\r\n    function area(model) {\r\n        var stack = model.stack();\r\n        var p = {};\r\n        if (stack && channel_1.X === stack.fieldChannel) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X) + '_start'\r\n            };\r\n            p.x2 = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X) + '_end'\r\n            };\r\n        }\r\n        else if (model.isMeasure(channel_1.X)) {\r\n            p.x = { scale: channel_1.X, field: model.field(channel_1.X) };\r\n            if (model.isDimension(channel_1.Y)) {\r\n                p.x2 = {\r\n                    scale: channel_1.X,\r\n                    value: 0\r\n                };\r\n                p.orient = { value: 'horizontal' };\r\n            }\r\n        }\r\n        else if (model.has(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else {\r\n            p.x = { value: 0 };\r\n        }\r\n        if (stack && channel_1.Y === stack.fieldChannel) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y) + '_start'\r\n            };\r\n            p.y2 = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y) + '_end'\r\n            };\r\n        }\r\n        else if (model.isMeasure(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y)\r\n            };\r\n            p.y2 = {\r\n                scale: channel_1.Y,\r\n                value: 0\r\n            };\r\n        }\r\n        else if (model.has(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else {\r\n            p.y = { field: { group: 'height' } };\r\n        }\r\n        if (model.has(channel_1.COLOR)) {\r\n            p.fill = {\r\n                scale: channel_1.COLOR,\r\n                field: model.field(channel_1.COLOR)\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.COLOR)) {\r\n            p.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity) {\r\n            p.opacity = { value: opacity };\r\n        }\r\n        return p;\r\n    }\r\n    properties.area = area;\r\n    function tick(model) {\r\n        var p = {};\r\n        if (model.has(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n            };\r\n            if (model.isDimension(channel_1.X)) {\r\n                p.x.offset = -model.fieldDef(channel_1.X).scale.bandWidth / 3;\r\n            }\r\n        }\r\n        else if (!model.has(channel_1.X)) {\r\n            p.x = { value: 0 };\r\n        }\r\n        if (model.has(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n            };\r\n            if (model.isDimension(channel_1.Y)) {\r\n                p.y.offset = -model.fieldDef(channel_1.Y).scale.bandWidth / 3;\r\n            }\r\n        }\r\n        else if (!model.has(channel_1.Y)) {\r\n            p.y = { value: 0 };\r\n        }\r\n        if (!model.has(channel_1.X) || model.isDimension(channel_1.X)) {\r\n            p.width = { value: model.fieldDef(channel_1.X).scale.bandWidth / 1.5 };\r\n        }\r\n        else {\r\n            p.width = { value: 1 };\r\n        }\r\n        if (!model.has(channel_1.Y) || model.isDimension(channel_1.Y)) {\r\n            p.height = { value: model.fieldDef(channel_1.Y).scale.bandWidth / 1.5 };\r\n        }\r\n        else {\r\n            p.height = { value: 1 };\r\n        }\r\n        if (model.has(channel_1.COLOR)) {\r\n            p.fill = {\r\n                scale: channel_1.COLOR,\r\n                field: model.field(channel_1.COLOR)\r\n            };\r\n        }\r\n        else {\r\n            p.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity) {\r\n            p.opacity = { value: opacity };\r\n        }\r\n        return p;\r\n    }\r\n    properties.tick = tick;\r\n    function filled_point_props(shape) {\r\n        return function (model) {\r\n            var p = {};\r\n            if (model.has(channel_1.X)) {\r\n                p.x = {\r\n                    scale: channel_1.X,\r\n                    field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.X)) {\r\n                p.x = { value: model.fieldDef(channel_1.X).scale.bandWidth / 2 };\r\n            }\r\n            if (model.has(channel_1.Y)) {\r\n                p.y = {\r\n                    scale: channel_1.Y,\r\n                    field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.Y)) {\r\n                p.y = { value: model.fieldDef(channel_1.Y).scale.bandWidth / 2 };\r\n            }\r\n            if (model.has(channel_1.SIZE)) {\r\n                p.size = {\r\n                    scale: channel_1.SIZE,\r\n                    field: model.field(channel_1.SIZE)\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.X)) {\r\n                p.size = { value: model.fieldDef(channel_1.SIZE).value };\r\n            }\r\n            p.shape = { value: shape };\r\n            if (model.has(channel_1.COLOR)) {\r\n                p.fill = {\r\n                    scale: channel_1.COLOR,\r\n                    field: model.field(channel_1.COLOR)\r\n                };\r\n            }\r\n            else if (!model.has(channel_1.COLOR)) {\r\n                p.fill = { value: model.fieldDef(channel_1.COLOR).value };\r\n            }\r\n            var opacity = model.config('marks').opacity;\r\n            if (opacity) {\r\n                p.opacity = { value: opacity };\r\n            }\r\n            return p;\r\n        };\r\n    }\r\n    properties.circle = filled_point_props('circle');\r\n    properties.square = filled_point_props('square');\r\n    function textBackground(model) {\r\n        return {\r\n            x: { value: 0 },\r\n            y: { value: 0 },\r\n            width: { field: { group: 'width' } },\r\n            height: { field: { group: 'height' } },\r\n            fill: { scale: channel_1.COLOR, field: model.field(channel_1.COLOR) }\r\n        };\r\n    }\r\n    properties.textBackground = textBackground;\r\n    function text(model) {\r\n        var p = {};\r\n        var fieldDef = model.fieldDef(channel_1.TEXT);\r\n        var marksConfig = model.config('marks');\r\n        if (model.has(channel_1.X)) {\r\n            p.x = {\r\n                scale: channel_1.X,\r\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.X)) {\r\n            if (model.has(channel_1.TEXT) && model.fieldDef(channel_1.TEXT).type === type_1.QUANTITATIVE) {\r\n                p.x = { field: { group: 'width' }, offset: -5 };\r\n            }\r\n            else {\r\n                p.x = { value: model.fieldDef(channel_1.X).scale.bandWidth / 2 };\r\n            }\r\n        }\r\n        if (model.has(channel_1.Y)) {\r\n            p.y = {\r\n                scale: channel_1.Y,\r\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.Y)) {\r\n            p.y = { value: model.fieldDef(channel_1.Y).scale.bandWidth / 2 };\r\n        }\r\n        if (model.has(channel_1.SIZE)) {\r\n            p.fontSize = {\r\n                scale: channel_1.SIZE,\r\n                field: model.field(channel_1.SIZE)\r\n            };\r\n        }\r\n        else if (!model.has(channel_1.SIZE)) {\r\n            p.fontSize = { value: fieldDef.fontSize };\r\n        }\r\n        var opacity = model.config('marks').opacity;\r\n        if (opacity) {\r\n            p.opacity = { value: opacity };\r\n        }\r\n        if (model.has(channel_1.TEXT)) {\r\n            if (model.fieldDef(channel_1.TEXT).type === type_1.QUANTITATIVE) {\r\n                var numberFormat = marksConfig.format !== undefined ?\r\n                    marksConfig.format : model.numberFormat(channel_1.TEXT);\r\n                p.text = { template: '{{' + model.field(channel_1.TEXT, { datum: true }) +\r\n                        ' | number:\\'' + numberFormat + '\\'}}' };\r\n            }\r\n            else {\r\n                p.text = { field: model.field(channel_1.TEXT) };\r\n            }\r\n        }\r\n        else {\r\n            p.text = { value: fieldDef.value };\r\n        }\r\n        ['align', 'baseline', 'fill', 'font', 'fontWeight', 'fontStyle']\r\n            .forEach(function (property) {\r\n            var value = marksConfig[property];\r\n            if (value !== undefined) {\r\n                p[property] = { value: value };\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n    properties.text = text;\r\n})(properties = exports.properties || (exports.properties = {}));\r\n},{\"../channel\":11,\"../marktype\":26,\"../type\":42,\"./stack\":21}],20:[function(require,module,exports){\nvar util_1 = require('../util');\r\nvar aggregate_1 = require('../aggregate');\r\nvar channel_1 = require('../channel');\r\nvar data_1 = require('../data');\r\nvar time = require('./time');\r\nvar type_1 = require('../type');\r\nfunction compileScales(names, model) {\r\n    return names.reduce(function (a, channel) {\r\n        var scaleDef = {\r\n            name: channel,\r\n            type: type(channel, model),\r\n        };\r\n        scaleDef.domain = domain(model, channel, scaleDef.type);\r\n        util_1.extend(scaleDef, rangeMixins(model, channel, scaleDef.type));\r\n        [\r\n            'reverse', 'round',\r\n            'clamp', 'nice',\r\n            'exponent', 'zero',\r\n            'bandWidth', 'outerPadding', 'padding', 'points'\r\n        ].forEach(function (property) {\r\n            var value = exports[property](model, channel, scaleDef.type);\r\n            if (value !== undefined) {\r\n                scaleDef[property] = value;\r\n            }\r\n        });\r\n        return (a.push(scaleDef), a);\r\n    }, []);\r\n}\r\nexports.compileScales = compileScales;\r\nfunction type(channel, model) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    switch (fieldDef.type) {\r\n        case type_1.NOMINAL:\r\n            return 'ordinal';\r\n        case type_1.ORDINAL:\r\n            var range = fieldDef.scale.range;\r\n            return channel === channel_1.COLOR && (typeof range !== 'string') ? 'linear' : 'ordinal';\r\n        case type_1.TEMPORAL:\r\n            return fieldDef.timeUnit ? time.scale.type(fieldDef.timeUnit, channel) : 'time';\r\n        case type_1.QUANTITATIVE:\r\n            if (model.bin(channel)) {\r\n                return channel === channel_1.ROW || channel === channel_1.COLUMN || channel === channel_1.SHAPE ? 'ordinal' : 'linear';\r\n            }\r\n            return fieldDef.scale.type;\r\n    }\r\n}\r\nexports.type = type;\r\nfunction domain(model, channel, type) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    if (fieldDef.scale.domain) {\r\n        return fieldDef.scale.domain;\r\n    }\r\n    if (fieldDef.type === type_1.TEMPORAL) {\r\n        var range = time.scale.domain(fieldDef.timeUnit, channel);\r\n        if (range)\r\n            return range;\r\n    }\r\n    var stack = model.stack();\r\n    if (stack && channel === stack.fieldChannel) {\r\n        var facet = model.has(channel_1.ROW) || model.has(channel_1.COLUMN);\r\n        return {\r\n            data: data_1.STACKED,\r\n            field: model.field(channel, {\r\n                prefn: (facet ? 'max_' : '') + 'sum_'\r\n            })\r\n        };\r\n    }\r\n    var useRawDomain = _useRawDomain(model, channel);\r\n    var sort = domainSort(model, channel, type);\r\n    if (useRawDomain) {\r\n        return {\r\n            data: data_1.SOURCE,\r\n            field: model.field(channel, { noAggregate: true })\r\n        };\r\n    }\r\n    else if (fieldDef.bin) {\r\n        return {\r\n            data: model.dataTable(),\r\n            field: type === 'ordinal' ?\r\n                model.field(channel, { binSuffix: '_start' }) :\r\n                [\r\n                    model.field(channel, { binSuffix: '_start' }),\r\n                    model.field(channel, { binSuffix: '_end' })\r\n                ]\r\n        };\r\n    }\r\n    else if (sort) {\r\n        return {\r\n            data: sort.op ? data_1.SOURCE : model.dataTable(),\r\n            field: model.field(channel),\r\n            sort: sort\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            data: model.dataTable(),\r\n            field: model.field(channel)\r\n        };\r\n    }\r\n}\r\nexports.domain = domain;\r\nfunction domainSort(model, channel, type) {\r\n    var sort = model.fieldDef(channel).sort;\r\n    if (sort === 'ascending' || sort === 'descending') {\r\n        return true;\r\n    }\r\n    if (type === 'ordinal' && typeof sort !== 'string') {\r\n        return {\r\n            op: sort.op,\r\n            field: sort.field\r\n        };\r\n    }\r\n    return undefined;\r\n}\r\nexports.domainSort = domainSort;\r\nfunction reverse(model, channel) {\r\n    var sort = model.fieldDef(channel).sort;\r\n    return sort && (typeof sort === 'string' ?\r\n        sort === 'descending' :\r\n        sort.order === 'descending') ? true : undefined;\r\n}\r\nexports.reverse = reverse;\r\nfunction _useRawDomain(model, channel) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    return fieldDef.scale.useRawDomain &&\r\n        fieldDef.aggregate &&\r\n        aggregate_1.SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&\r\n        ((fieldDef.type === type_1.QUANTITATIVE && !fieldDef.bin) ||\r\n            (fieldDef.type === type_1.TEMPORAL &&\r\n                (!fieldDef.timeUnit || time.scale.type(fieldDef.timeUnit, channel) === 'linear')));\r\n}\r\nexports._useRawDomain = _useRawDomain;\r\nfunction bandWidth(model, channel, scaleType) {\r\n    if (scaleType === 'ordinal') {\r\n        return model.fieldDef(channel).scale.bandWidth;\r\n    }\r\n    return undefined;\r\n}\r\nexports.bandWidth = bandWidth;\r\nfunction clamp(model, channel) {\r\n    return model.fieldDef(channel).scale.clamp;\r\n}\r\nexports.clamp = clamp;\r\nfunction exponent(model, channel) {\r\n    return model.fieldDef(channel).scale.exponent;\r\n}\r\nexports.exponent = exponent;\r\nfunction nice(model, channel, scaleType) {\r\n    if (model.fieldDef(channel).scale.nice !== undefined) {\r\n        return model.fieldDef(channel).scale.nice;\r\n    }\r\n    switch (channel) {\r\n        case channel_1.X:\r\n        case channel_1.Y:\r\n            if (scaleType === 'time' || scaleType === 'ordinal') {\r\n                return undefined;\r\n            }\r\n            return true;\r\n        case channel_1.ROW:\r\n        case channel_1.COLUMN:\r\n            return true;\r\n    }\r\n    return undefined;\r\n}\r\nexports.nice = nice;\r\nfunction outerPadding(model, channel, scaleType) {\r\n    if (scaleType === 'ordinal') {\r\n        if (model.fieldDef(channel).scale.outerPadding !== undefined) {\r\n            return model.fieldDef(channel).scale.outerPadding;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nexports.outerPadding = outerPadding;\r\nfunction padding(model, channel, scaleType) {\r\n    if (scaleType === 'ordinal') {\r\n        return model.fieldDef(channel).scale.padding;\r\n    }\r\n    return undefined;\r\n}\r\nexports.padding = padding;\r\nfunction points(model, channel, scaleType) {\r\n    if (scaleType === 'ordinal') {\r\n        if (model.fieldDef(channel).scale.points !== undefined) {\r\n            return model.fieldDef(channel).scale.points;\r\n        }\r\n        switch (channel) {\r\n            case channel_1.X:\r\n            case channel_1.Y:\r\n                return true;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nexports.points = points;\r\nfunction rangeMixins(model, channel, scaleType) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    if (fieldDef.scale.range) {\r\n        return { range: fieldDef.scale.range };\r\n    }\r\n    switch (channel) {\r\n        case channel_1.X:\r\n            return { rangeMin: 0, rangeMax: model.layout().cellWidth };\r\n        case channel_1.Y:\r\n            if (scaleType === 'ordinal') {\r\n                return { rangeMin: 0, rangeMax: model.layout().cellHeight };\r\n            }\r\n            return { rangeMin: model.layout().cellHeight, rangeMax: 0 };\r\n        case channel_1.SIZE:\r\n            if (model.is('bar')) {\r\n                return {\r\n                    range: [3, Math.max(model.fieldDef(channel_1.X).scale.bandWidth, model.fieldDef(channel_1.Y).scale.bandWidth)]\r\n                };\r\n            }\r\n            else if (model.is(channel_1.TEXT)) {\r\n                return { range: [8, 40] };\r\n            }\r\n            var bandWidth = Math.min(model.fieldDef(channel_1.X).scale.bandWidth, model.fieldDef(channel_1.Y).scale.bandWidth) - 1;\r\n            return { range: [10, 0.8 * bandWidth * bandWidth] };\r\n        case channel_1.SHAPE:\r\n            return { range: 'shapes' };\r\n        case channel_1.COLOR:\r\n            if (scaleType === 'ordinal') {\r\n                return { range: 'category10' };\r\n            }\r\n            else {\r\n                return { range: ['#AFC6A3', '#09622A'] };\r\n            }\r\n        case channel_1.ROW:\r\n            return { range: 'height' };\r\n        case channel_1.COLUMN:\r\n            return { range: 'width' };\r\n    }\r\n    return {};\r\n}\r\nexports.rangeMixins = rangeMixins;\r\nfunction round(model, channel) {\r\n    if (model.fieldDef(channel).scale.round !== undefined) {\r\n        return model.fieldDef(channel).scale.round;\r\n    }\r\n    switch (channel) {\r\n        case channel_1.X:\r\n        case channel_1.Y:\r\n        case channel_1.ROW:\r\n        case channel_1.COLUMN:\r\n        case channel_1.SIZE:\r\n            return true;\r\n    }\r\n    return undefined;\r\n}\r\nexports.round = round;\r\nfunction zero(model, channel) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    var timeUnit = fieldDef.timeUnit;\r\n    if (fieldDef.scale.zero !== undefined) {\r\n        return fieldDef.scale.zero;\r\n    }\r\n    if (fieldDef.type === type_1.TEMPORAL) {\r\n        if (timeUnit === 'year') {\r\n            return false;\r\n        }\r\n        return undefined;\r\n    }\r\n    if (fieldDef.bin) {\r\n        return false;\r\n    }\r\n    return channel === channel_1.X || channel === channel_1.Y ?\r\n        undefined :\r\n        false;\r\n}\r\nexports.zero = zero;\r\n},{\"../aggregate\":9,\"../channel\":11,\"../data\":23,\"../type\":42,\"../util\":43,\"./time\":22}],21:[function(require,module,exports){\nvar util_1 = require('../util');\r\nfunction imputeTransform(model) {\r\n    var stack = model.stack();\r\n    return {\r\n        type: 'impute',\r\n        field: model.field(stack.fieldChannel),\r\n        groupby: [model.field(stack.stackChannel)],\r\n        orderby: [model.field(stack.groupbyChannel)],\r\n        method: 'value',\r\n        value: 0\r\n    };\r\n}\r\nexports.imputeTransform = imputeTransform;\r\nfunction stackTransform(model) {\r\n    var stack = model.stack();\r\n    var sortby = stack.config.sort === 'descending' ?\r\n        '-' + model.field(stack.stackChannel) :\r\n        stack.config.sort === 'ascending' ?\r\n            model.field(stack.stackChannel) :\r\n            util_1.isObject(stack.config.sort) ?\r\n                stack.config.sort :\r\n                '-' + model.field(stack.stackChannel);\r\n    var valName = model.field(stack.fieldChannel);\r\n    var transform = {\r\n        type: 'stack',\r\n        groupby: [model.field(stack.groupbyChannel)],\r\n        field: model.field(stack.fieldChannel),\r\n        sortby: sortby,\r\n        output: {\r\n            start: valName + '_start',\r\n            end: valName + '_end'\r\n        }\r\n    };\r\n    if (stack.config.offset) {\r\n        transform.offset = stack.config.offset;\r\n    }\r\n    return transform;\r\n}\r\nexports.stackTransform = stackTransform;\r\n},{\"../util\":43}],22:[function(require,module,exports){\nvar util = require('../util');\r\nvar channel_1 = require('../channel');\r\nfunction cardinality(fieldDef, stats, filterNull, type) {\r\n    var timeUnit = fieldDef.timeUnit;\r\n    switch (timeUnit) {\r\n        case 'seconds': return 60;\r\n        case 'minutes': return 60;\r\n        case 'hours': return 24;\r\n        case 'day': return 7;\r\n        case 'date': return 31;\r\n        case 'month': return 12;\r\n        case 'year':\r\n            var stat = stats[fieldDef.field], yearstat = stats['year_' + fieldDef.field];\r\n            if (!yearstat) {\r\n                return null;\r\n            }\r\n            return yearstat.distinct -\r\n                (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n    }\r\n    return null;\r\n}\r\nexports.cardinality = cardinality;\r\nfunction formula(timeUnit, field) {\r\n    var fn = 'utc' + timeUnit;\r\n    return fn + '(' + field + ')';\r\n}\r\nexports.formula = formula;\r\nfunction range(timeUnit, model) {\r\n    var labelLength = model.config('timeScaleLabelLength'), scaleLabel;\r\n    switch (timeUnit) {\r\n        case 'day':\r\n            scaleLabel = model.config('dayScaleLabel');\r\n            break;\r\n        case 'month':\r\n            scaleLabel = model.config('monthScaleLabel');\r\n            break;\r\n    }\r\n    if (scaleLabel) {\r\n        return labelLength ? scaleLabel.map(function (s) { return s.substr(0, labelLength); }) : scaleLabel;\r\n    }\r\n    return;\r\n}\r\nexports.range = range;\r\nfunction isOrdinalFn(timeUnit) {\r\n    switch (timeUnit) {\r\n        case 'seconds':\r\n        case 'minutes':\r\n        case 'hours':\r\n        case 'day':\r\n        case 'date':\r\n        case 'month':\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nvar scale;\r\n(function (scale) {\r\n    function type(timeUnit, channel) {\r\n        if (channel === channel_1.COLOR) {\r\n            return 'linear';\r\n        }\r\n        return isOrdinalFn(timeUnit) || channel === channel_1.COLUMN || channel === channel_1.ROW ? 'ordinal' : 'linear';\r\n    }\r\n    scale.type = type;\r\n    function domain(timeUnit, channel) {\r\n        var isColor = channel === channel_1.COLOR;\r\n        switch (timeUnit) {\r\n            case 'seconds':\r\n            case 'minutes': return isColor ? [0, 59] : util.range(0, 60);\r\n            case 'hours': return isColor ? [0, 23] : util.range(0, 24);\r\n            case 'day': return isColor ? [0, 6] : util.range(0, 7);\r\n            case 'date': return isColor ? [1, 31] : util.range(1, 32);\r\n            case 'month': return isColor ? [0, 11] : util.range(0, 12);\r\n        }\r\n        return null;\r\n    }\r\n    scale.domain = domain;\r\n})(scale = exports.scale || (exports.scale = {}));\r\nfunction labelTemplate(timeUnit, abbreviated) {\r\n    if (abbreviated === void 0) { abbreviated = false; }\r\n    var postfix = abbreviated ? '-abbrev' : '';\r\n    switch (timeUnit) {\r\n        case 'day':\r\n            return 'day' + postfix;\r\n        case 'month':\r\n            return 'month' + postfix;\r\n    }\r\n    return null;\r\n}\r\nexports.labelTemplate = labelTemplate;\r\n},{\"../channel\":11,\"../util\":43}],23:[function(require,module,exports){\nvar type_1 = require('./type');\r\nexports.SUMMARY = 'summary';\r\nexports.SOURCE = 'source';\r\nexports.STACKED = 'stacked';\r\nexports.LAYOUT = 'layout';\r\nexports.types = {\r\n    'boolean': type_1.NOMINAL,\r\n    'number': type_1.QUANTITATIVE,\r\n    'integer': type_1.QUANTITATIVE,\r\n    'date': type_1.TEMPORAL,\r\n    'string': type_1.NOMINAL\r\n};\r\n},{\"./type\":42}],24:[function(require,module,exports){\nvar channel_1 = require('./channel');\r\nfunction countRetinal(encoding) {\r\n    var count = 0;\r\n    if (encoding.color)\r\n        count++;\r\n    if (encoding.size)\r\n        count++;\r\n    if (encoding.shape)\r\n        count++;\r\n    return count;\r\n}\r\nexports.countRetinal = countRetinal;\r\nfunction has(encoding, channel) {\r\n    var fieldDef = encoding && encoding[channel];\r\n    return fieldDef && fieldDef.field;\r\n}\r\nexports.has = has;\r\nfunction isAggregate(encoding) {\r\n    for (var k in encoding) {\r\n        if (has(encoding, k) && encoding[k].aggregate) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isAggregate = isAggregate;\r\nfunction forEach(encoding, f) {\r\n    var i = 0;\r\n    channel_1.CHANNELS.forEach(function (channel) {\r\n        if (has(encoding, channel)) {\r\n            f(encoding[channel], channel, i++);\r\n        }\r\n    });\r\n}\r\nexports.forEach = forEach;\r\nfunction map(encoding, f) {\r\n    var arr = [];\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            arr.push(f(encoding[k], k, encoding));\r\n        }\r\n    });\r\n    return arr;\r\n}\r\nexports.map = map;\r\nfunction reduce(encoding, f, init) {\r\n    var r = init;\r\n    channel_1.CHANNELS.forEach(function (k) {\r\n        if (has(encoding, k)) {\r\n            r = f(r, encoding[k], k, encoding);\r\n        }\r\n    });\r\n    return r;\r\n}\r\nexports.reduce = reduce;\r\n},{\"./channel\":11}],25:[function(require,module,exports){\nvar bin_1 = require('./bin');\r\nvar util_1 = require('./util');\r\nvar time = require('./compiler/time');\r\nvar type_1 = require('./type');\r\nfunction _isFieldDimension(fieldDef) {\r\n    return util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin ||\r\n        (fieldDef.type === type_1.TEMPORAL && !!fieldDef.timeUnit);\r\n}\r\nfunction isDimension(fieldDef) {\r\n    return fieldDef && _isFieldDimension(fieldDef);\r\n}\r\nexports.isDimension = isDimension;\r\nfunction isMeasure(fieldDef) {\r\n    return fieldDef && !_isFieldDimension(fieldDef);\r\n}\r\nexports.isMeasure = isMeasure;\r\nfunction count() {\r\n    return { field: '*', aggregate: 'count', type: type_1.QUANTITATIVE, displayName: exports.COUNT_DISPLAYNAME };\r\n}\r\nexports.count = count;\r\nexports.COUNT_DISPLAYNAME = 'Number of Records';\r\nfunction isCount(fieldDef) {\r\n    return fieldDef.aggregate === 'count';\r\n}\r\nexports.isCount = isCount;\r\nfunction cardinality(fieldDef, stats, filterNull) {\r\n    if (filterNull === void 0) { filterNull = {}; }\r\n    var stat = stats[fieldDef.field];\r\n    var type = fieldDef.type;\r\n    if (fieldDef.bin) {\r\n        var bin = fieldDef.bin;\r\n        var maxbins = (typeof bin === 'boolean') ? bin_1.MAXBINS_DEFAULT : bin.maxbins;\r\n        var bins = util_1.getbins(stat, maxbins);\r\n        return (bins.stop - bins.start) / bins.step;\r\n    }\r\n    if (fieldDef.type === type_1.TEMPORAL) {\r\n        var cardinality = time.cardinality(fieldDef, stats, filterNull, type);\r\n        if (cardinality !== null)\r\n            return cardinality;\r\n    }\r\n    if (fieldDef.aggregate) {\r\n        return 1;\r\n    }\r\n    return stat.distinct -\r\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n}\r\nexports.cardinality = cardinality;\r\n},{\"./bin\":10,\"./compiler/time\":22,\"./type\":42,\"./util\":43}],26:[function(require,module,exports){\nexports.AREA = 'area';\r\nexports.BAR = 'bar';\r\nexports.LINE = 'line';\r\nexports.POINT = 'point';\r\nexports.TEXT = 'text';\r\nexports.TICK = 'tick';\r\nexports.CIRCLE = 'circle';\r\nexports.SQUARE = 'square';\r\n},{}],27:[function(require,module,exports){\nexports.axis = {\r\n    type: 'object',\r\n    properties: {\r\n        format: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'The formatting pattern for axis labels. ' +\r\n                'If not undefined, this will be determined by ' +\r\n                'the max value ' +\r\n                'of the field.'\r\n        },\r\n        grid: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\r\n        },\r\n        layer: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\r\n        },\r\n        orient: {\r\n            type: 'string',\r\n            default: undefined,\r\n            enum: ['top', 'right', 'left', 'bottom'],\r\n            description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\r\n        },\r\n        ticks: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\r\n        },\r\n        title: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A title for the axis. (Shows field name and its function by default.)'\r\n        },\r\n        labelMaxLength: {\r\n            type: 'integer',\r\n            default: 25,\r\n            minimum: 0,\r\n            description: 'Truncate labels that are too long.'\r\n        },\r\n        titleMaxLength: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            minimum: 0,\r\n            description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\r\n        },\r\n        titleOffset: {\r\n            type: 'integer',\r\n            default: undefined,\r\n            description: 'A title offset value for the axis.'\r\n        },\r\n        shortTimeNames: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Whether month names and weekday names should be abbreviated.'\r\n        },\r\n        properties: {\r\n            type: 'object',\r\n            default: undefined,\r\n            description: 'Optional mark property definitions for custom axis styling.'\r\n        }\r\n    }\r\n};\r\n},{}],28:[function(require,module,exports){\nvar bin_1 = require('../bin');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.bin = {\r\n    type: ['boolean', 'object'],\r\n    default: false,\r\n    properties: {\r\n        maxbins: {\r\n            type: 'integer',\r\n            default: bin_1.MAXBINS_DEFAULT,\r\n            minimum: 2,\r\n            description: 'Maximum number of bins.'\r\n        }\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n};\r\n},{\"../bin\":10,\"../type\":42,\"../util\":43}],29:[function(require,module,exports){\nexports.config = {\r\n    type: 'object',\r\n    properties: {\r\n        width: {\r\n            type: 'integer',\r\n            default: undefined\r\n        },\r\n        height: {\r\n            type: 'integer',\r\n            default: undefined\r\n        },\r\n        viewport: {\r\n            type: 'array',\r\n            items: {\r\n                type: 'integer'\r\n            },\r\n            default: undefined\r\n        },\r\n        filterNull: {\r\n            type: 'object',\r\n            properties: {\r\n                nominal: { type: 'boolean', default: false },\r\n                ordinal: { type: 'boolean', default: false },\r\n                quantitative: { type: 'boolean', default: true },\r\n                temporal: { type: 'boolean', default: true }\r\n            }\r\n        },\r\n        textCellWidth: {\r\n            type: 'integer',\r\n            default: 90,\r\n            minimum: 0\r\n        },\r\n        sortLineBy: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'Data field to sort line by. ' +\r\n                '\\'-\\' prefix can be added to suggest descending order.'\r\n        },\r\n        stack: {\r\n            type: ['boolean', 'object'],\r\n            default: {},\r\n            description: 'Enable stacking (for bar and area marks only).',\r\n            properties: {\r\n                sort: {\r\n                    oneOf: [{\r\n                            type: 'string',\r\n                            enum: ['ascending', 'descending']\r\n                        }, {\r\n                            type: 'array',\r\n                            items: { type: 'string' },\r\n                        }],\r\n                    description: 'Order of the stack. ' +\r\n                        'This can be either a string (either \"descending\" or \"ascending\")' +\r\n                        'or a list of fields to determine the order of stack layers.' +\r\n                        'By default, stack uses descending order.'\r\n                },\r\n                offset: {\r\n                    type: 'string',\r\n                    enum: ['zero', 'center', 'normalize']\r\n                }\r\n            }\r\n        },\r\n        cell: {\r\n            type: 'object',\r\n            properties: {\r\n                width: {\r\n                    type: 'integer',\r\n                    default: 200\r\n                },\r\n                height: {\r\n                    type: 'integer',\r\n                    default: 200\r\n                },\r\n                padding: {\r\n                    type: 'integer',\r\n                    default: 16,\r\n                    description: 'default padding between facets.'\r\n                },\r\n                gridColor: {\r\n                    type: 'string',\r\n                    role: 'color',\r\n                    default: '#000000'\r\n                },\r\n                gridOpacity: {\r\n                    type: 'number',\r\n                    minimum: 0,\r\n                    maximum: 1,\r\n                    default: 0.25\r\n                },\r\n                gridOffset: {\r\n                    type: 'number',\r\n                    default: 6\r\n                },\r\n                fill: {\r\n                    type: 'string',\r\n                    role: 'color',\r\n                    default: 'rgba(0,0,0,0)'\r\n                },\r\n                fillOpacity: {\r\n                    type: 'number',\r\n                },\r\n                stroke: {\r\n                    type: 'string',\r\n                    role: 'color',\r\n                },\r\n                strokeWidth: {\r\n                    type: 'integer'\r\n                },\r\n                strokeOpacity: {\r\n                    type: 'number'\r\n                },\r\n                strokeDash: {\r\n                    type: 'array',\r\n                    default: undefined\r\n                },\r\n                strokeDashOffset: {\r\n                    type: 'integer',\r\n                    description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n                }\r\n            }\r\n        },\r\n        marks: {\r\n            type: 'object',\r\n            properties: {\r\n                filled: {\r\n                    type: 'boolean',\r\n                    default: false,\r\n                    description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\r\n                },\r\n                format: {\r\n                    type: 'string',\r\n                    default: '',\r\n                    description: 'The formatting pattern for text value.' +\r\n                        'If not defined, this will be determined automatically'\r\n                },\r\n                opacity: {\r\n                    type: 'number',\r\n                    default: undefined,\r\n                    minimum: 0,\r\n                    maximum: 1\r\n                },\r\n                strokeWidth: {\r\n                    type: 'integer',\r\n                    default: 2,\r\n                    minimum: 0\r\n                },\r\n                align: {\r\n                    type: 'string',\r\n                    default: 'right',\r\n                    enum: ['left', 'right', 'center'],\r\n                    description: 'The horizontal alignment of the text. One of left, right, center.'\r\n                },\r\n                baseline: {\r\n                    type: 'string',\r\n                    default: 'middle',\r\n                    enum: ['top', 'middle', 'bottom'],\r\n                    description: 'The vertical alignment of the text. One of top, middle, bottom.'\r\n                },\r\n                fill: {\r\n                    type: 'string',\r\n                    role: 'color',\r\n                    default: '#000000'\r\n                },\r\n                font: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    role: 'font',\r\n                    description: 'The typeface to set the text in (e.g., Helvetica Neue).'\r\n                },\r\n                fontSize: {\r\n                    type: 'integer',\r\n                    default: undefined,\r\n                    minimum: 0,\r\n                    description: 'The font size, in pixels.'\r\n                },\r\n                fontStyle: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    enum: ['normal', 'italic'],\r\n                    description: 'The font style (e.g., italic).'\r\n                },\r\n                fontWeight: {\r\n                    type: 'string',\r\n                    enum: ['normal', 'bold'],\r\n                    default: undefined,\r\n                    description: 'The font weight (e.g., bold).'\r\n                }\r\n            }\r\n        },\r\n        singleBarOffset: {\r\n            type: 'integer',\r\n            default: 5,\r\n            minimum: 0\r\n        },\r\n        characterWidth: {\r\n            type: 'integer',\r\n            default: 6\r\n        },\r\n        numberFormat: {\r\n            type: 'string',\r\n            default: 's',\r\n            description: 'D3 Number format for axis labels and text tables.'\r\n        },\r\n        timeFormat: {\r\n            type: 'string',\r\n            default: '%Y-%m-%d',\r\n            description: 'Date format for axis labels.'\r\n        }\r\n    }\r\n};\r\n},{}],30:[function(require,module,exports){\nexports.data = {\r\n    type: 'object',\r\n    properties: {\r\n        formatType: {\r\n            type: 'string',\r\n            enum: ['json', 'csv', 'tsv'],\r\n            default: 'json'\r\n        },\r\n        url: {\r\n            type: 'string',\r\n            default: undefined\r\n        },\r\n        values: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Pass array of objects instead of a url to a file.',\r\n            items: {\r\n                type: 'object',\r\n                additionalProperties: true\r\n            }\r\n        },\r\n        filter: {\r\n            type: 'string',\r\n            default: undefined,\r\n            description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\r\n        },\r\n        calculate: {\r\n            type: 'array',\r\n            default: undefined,\r\n            description: 'Calculate new field(s) using the provided expresssion(s). Calculation are applied before filter.',\r\n            items: {\r\n                type: 'object',\r\n                properties: {\r\n                    field: {\r\n                        type: 'string',\r\n                        description: 'The field in which to store the computed formula value.'\r\n                    },\r\n                    expr: {\r\n                        type: 'string',\r\n                        description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n},{}],31:[function(require,module,exports){\nvar schemautil_1 = require('./schemautil');\r\nvar util_1 = require('../util');\r\nvar axis_schema_1 = require('./axis.schema');\r\nvar legend_schema_1 = require('./legend.schema');\r\nvar sort_schema_1 = require('./sort.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nvar requiredNameType = {\r\n    required: ['field', 'type']\r\n};\r\nvar x = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), requiredNameType, {\r\n    properties: {\r\n        scale: {\r\n            properties: {\r\n                padding: { default: 1 },\r\n                bandWidth: { default: 21 }\r\n            }\r\n        },\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar y = util_1.duplicate(x);\r\nvar facet = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), requiredNameType, {\r\n    properties: {\r\n        axis: axis_schema_1.axis,\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar row = schemautil_1.merge(util_1.duplicate(facet));\r\nvar column = schemautil_1.merge(util_1.duplicate(facet));\r\nvar size = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'integer',\r\n            default: 30,\r\n            minimum: 0,\r\n            description: 'Size of marks.'\r\n        }\r\n    }\r\n});\r\nvar color = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            role: 'color',\r\n            default: '#4682b4',\r\n            description: 'Color to be used for marks.'\r\n        },\r\n        scale: {\r\n            type: 'object',\r\n            properties: {\r\n                quantitativeRange: {\r\n                    type: 'array',\r\n                    default: ['#AFC6A3', '#09622A'],\r\n                    description: 'Color range to encode quantitative variables.',\r\n                    minItems: 2,\r\n                    maxItems: 2,\r\n                    items: {\r\n                        type: 'string',\r\n                        role: 'color'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\nvar shape = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        legend: legend_schema_1.legend,\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\r\n            default: 'circle',\r\n            description: 'Mark to be used.'\r\n        }\r\n    }\r\n});\r\nvar detail = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.onlyOrdinalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort\r\n    }\r\n});\r\nvar text = schemautil_1.merge(util_1.duplicate(fielddef_schema_1.typicalField), {\r\n    properties: {\r\n        sort: sort_schema_1.sort,\r\n        value: {\r\n            type: 'string',\r\n            default: 'Abc'\r\n        }\r\n    }\r\n});\r\nexports.encoding = {\r\n    type: 'object',\r\n    properties: {\r\n        x: x,\r\n        y: y,\r\n        row: row,\r\n        column: column,\r\n        size: size,\r\n        color: color,\r\n        shape: shape,\r\n        text: text,\r\n        detail: detail\r\n    }\r\n};\r\n},{\"../util\":43,\"./axis.schema\":27,\"./fielddef.schema\":32,\"./legend.schema\":33,\"./schemautil\":37,\"./sort.schema\":38}],32:[function(require,module,exports){\nvar bin_schema_1 = require('./bin.schema');\r\nvar scale_schema_1 = require('./scale.schema');\r\nvar aggregate_1 = require('../aggregate');\r\nvar util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar timeunit_1 = require('../timeunit');\r\nvar type_1 = require('../type');\r\nexports.fieldDef = {\r\n    type: 'object',\r\n    properties: {\r\n        field: {\r\n            type: 'string'\r\n        },\r\n        type: {\r\n            type: 'string',\r\n            enum: [type_1.NOMINAL, type_1.ORDINAL, type_1.QUANTITATIVE, type_1.TEMPORAL]\r\n        },\r\n        timeUnit: {\r\n            type: 'string',\r\n            enum: timeunit_1.TIMEUNITS,\r\n            supportedTypes: util_1.toMap([type_1.TEMPORAL])\r\n        },\r\n        bin: bin_schema_1.bin,\r\n    }\r\n};\r\nexports.aggregate = {\r\n    type: 'string',\r\n    enum: aggregate_1.AGGREGATE_OPS,\r\n    supportedEnums: {\r\n        quantitative: aggregate_1.AGGREGATE_OPS,\r\n        ordinal: ['median', 'min', 'max'],\r\n        nominal: [],\r\n        temporal: ['mean', 'median', 'min', 'max'],\r\n        '': ['count']\r\n    },\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.NOMINAL, type_1.ORDINAL, type_1.TEMPORAL, ''])\r\n};\r\nexports.typicalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        aggregate: exports.aggregate,\r\n        scale: scale_schema_1.typicalScale\r\n    }\r\n});\r\nexports.onlyOrdinalField = schemautil_1.merge(util_1.duplicate(exports.fieldDef), {\r\n    properties: {\r\n        aggregate: {\r\n            type: 'string',\r\n            enum: ['count'],\r\n            supportedTypes: util_1.toMap([type_1.NOMINAL, type_1.ORDINAL])\r\n        },\r\n        scale: scale_schema_1.ordinalOnlyScale\r\n    }\r\n});\r\n},{\"../aggregate\":9,\"../timeunit\":41,\"../type\":42,\"../util\":43,\"./bin.schema\":28,\"./scale.schema\":35,\"./schemautil\":37}],33:[function(require,module,exports){\nexports.legend = {\r\n    default: true,\r\n    description: 'Properties of a legend or boolean flag for determining whether to show it.',\r\n    oneOf: [{\r\n            type: 'object',\r\n            properties: {\r\n                orient: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\r\n                },\r\n                title: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'A title for the legend. (Shows field name and its function by default.)'\r\n                },\r\n                format: {\r\n                    type: 'string',\r\n                    default: undefined,\r\n                    description: 'An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.'\r\n                },\r\n                values: {\r\n                    type: 'array',\r\n                    default: undefined,\r\n                    description: 'Explicitly set the visible legend values.'\r\n                },\r\n                properties: {\r\n                    type: 'object',\r\n                    default: undefined,\r\n                    description: 'Optional mark property definitions for custom legend styling. '\r\n                }\r\n            }\r\n        }, {\r\n            type: 'boolean'\r\n        }]\r\n};\r\n},{}],34:[function(require,module,exports){\nexports.marktype = {\r\n    type: 'string',\r\n    enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\r\n};\r\n},{}],35:[function(require,module,exports){\nvar util_1 = require('../util');\r\nvar schemautil_1 = require('./schemautil');\r\nvar type_1 = require('../type');\r\nvar scale = {\r\n    type: 'object',\r\n    properties: {\r\n        type: {\r\n            type: 'string',\r\n            enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\r\n            default: 'linear',\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE])\r\n        },\r\n        domain: {\r\n            default: undefined,\r\n            type: ['array', 'object'],\r\n            description: 'The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values. The domain may also be specified by a reference to a data source.'\r\n        },\r\n        range: {\r\n            default: undefined,\r\n            type: ['array', 'object', 'string'],\r\n            description: 'The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.'\r\n        },\r\n        round: {\r\n            default: undefined,\r\n            type: 'boolean',\r\n            description: 'If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.'\r\n        }\r\n    }\r\n};\r\nvar ordinalScaleMixin = {\r\n    properties: {\r\n        bandWidth: {\r\n            type: 'integer',\r\n            minimum: 0,\r\n            default: undefined\r\n        },\r\n        outerPadding: {\r\n            type: 'number',\r\n            default: undefined\r\n        },\r\n        padding: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).'\r\n        },\r\n        points: {\r\n            type: 'boolean',\r\n            default: undefined,\r\n            description: 'If true, distributes the ordinal values over a quantitative range at uniformly spaced points. The spacing of the points can be adjusted using the padding property. If false, the ordinal scale will construct evenly-spaced bands, rather than points.'\r\n        }\r\n    }\r\n};\r\nvar typicalScaleMixin = {\r\n    properties: {\r\n        clamp: {\r\n            type: 'boolean',\r\n            default: true,\r\n            description: 'If true, values that exceed the data domain are clamped to either the minimum or maximum range value'\r\n        },\r\n        nice: {\r\n            default: undefined,\r\n            oneOf: [\r\n                {\r\n                    type: 'boolean',\r\n                    description: 'If true, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96).'\r\n                }, {\r\n                    type: 'string',\r\n                    enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\r\n                    description: 'If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval; legal values are \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", or \"year\".'\r\n                }\r\n            ],\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL]),\r\n            description: ''\r\n        },\r\n        exponent: {\r\n            type: 'number',\r\n            default: undefined,\r\n            description: 'Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.'\r\n        },\r\n        zero: {\r\n            type: 'boolean',\r\n            description: 'If true, ensures that a zero baseline value is included in the scale domain. This option is ignored for non-quantitative scales.',\r\n            default: undefined,\r\n            supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.TEMPORAL])\r\n        },\r\n        useRawDomain: {\r\n            type: 'boolean',\r\n            default: false,\r\n            description: 'Uses the source data range as scale domain instead of ' +\r\n                'aggregated data for aggregate axis. ' +\r\n                'This option does not work with sum or count aggregate' +\r\n                'as they might have a substantially larger scale range.'\r\n        }\r\n    }\r\n};\r\nexports.ordinalOnlyScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin);\r\nexports.typicalScale = schemautil_1.merge(util_1.duplicate(scale), ordinalScaleMixin, typicalScaleMixin);\r\n},{\"../type\":42,\"../util\":43,\"./schemautil\":37}],36:[function(require,module,exports){\nvar schemaUtil = require('./schemautil');\r\nvar marktype_schema_1 = require('./marktype.schema');\r\nvar config_schema_1 = require('./config.schema');\r\nvar data_schema_1 = require('./data.schema');\r\nvar encoding_schema_1 = require('./encoding.schema');\r\nvar fielddef_schema_1 = require('./fielddef.schema');\r\nexports.aggregate = fielddef_schema_1.aggregate;\r\nexports.util = schemaUtil;\r\nexports.schema = {\r\n    $schema: 'http://json-schema.org/draft-04/schema#',\r\n    description: 'Schema for Vega-lite specification',\r\n    type: 'object',\r\n    required: ['marktype', 'encoding'],\r\n    properties: {\r\n        data: data_schema_1.data,\r\n        marktype: marktype_schema_1.marktype,\r\n        encoding: encoding_schema_1.encoding,\r\n        config: config_schema_1.config\r\n    }\r\n};\r\nfunction instantiate() {\r\n    return schemaUtil.instantiate(exports.schema);\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\n},{\"./config.schema\":29,\"./data.schema\":30,\"./encoding.schema\":31,\"./fielddef.schema\":32,\"./marktype.schema\":34,\"./schemautil\":37}],37:[function(require,module,exports){\nvar util = require('../util');\r\nfunction isEmpty(obj) {\r\n    return Object.keys(obj).length === 0;\r\n}\r\n;\r\nfunction extend(instance, schema) {\r\n    return merge(instantiate(schema), instance);\r\n}\r\nexports.extend = extend;\r\n;\r\nfunction instantiate(schema) {\r\n    var val;\r\n    if (schema === undefined) {\r\n        return undefined;\r\n    }\r\n    else if ('default' in schema) {\r\n        val = schema.default;\r\n        return util.isObject(val) ? util.duplicate(val) : val;\r\n    }\r\n    else if (schema.type === 'object') {\r\n        var instance = {};\r\n        for (var name in schema.properties) {\r\n            val = instantiate(schema.properties[name]);\r\n            if (val !== undefined) {\r\n                instance[name] = val;\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    else if (schema.type === 'array') {\r\n        return undefined;\r\n    }\r\n    return undefined;\r\n}\r\nexports.instantiate = instantiate;\r\n;\r\nfunction subtract(instance, defaults) {\r\n    var changes = {};\r\n    for (var prop in instance) {\r\n        var def = defaults[prop];\r\n        var ins = instance[prop];\r\n        if (!defaults || def !== ins) {\r\n            if (typeof ins === 'object' && !util.isArray(ins) && def) {\r\n                var c = subtract(ins, def);\r\n                if (!isEmpty(c)) {\r\n                    changes[prop] = c;\r\n                }\r\n            }\r\n            else if (util.isArray(ins)) {\r\n                if (util.isArray(def)) {\r\n                    if (ins.length === def.length) {\r\n                        var equal = true;\r\n                        for (var i = 0; i < ins.length; i++) {\r\n                            if (ins[i] !== def[i]) {\r\n                                equal = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (equal) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                changes[prop] = ins;\r\n            }\r\n            else {\r\n                changes[prop] = ins;\r\n            }\r\n        }\r\n    }\r\n    return changes;\r\n}\r\nexports.subtract = subtract;\r\n;\r\nfunction merge(dest) {\r\n    var src = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        src[_i - 1] = arguments[_i];\r\n    }\r\n    for (var i = 0; i < src.length; i++) {\r\n        dest = merge_(dest, src[i]);\r\n    }\r\n    return dest;\r\n}\r\nexports.merge = merge;\r\n;\r\nfunction merge_(dest, src) {\r\n    if (typeof src !== 'object' || src === null) {\r\n        return dest;\r\n    }\r\n    for (var p in src) {\r\n        if (!src.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (src[p] === undefined) {\r\n            continue;\r\n        }\r\n        if (typeof src[p] !== 'object' || src[p] === null) {\r\n            dest[p] = src[p];\r\n        }\r\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\r\n            dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\r\n        }\r\n        else {\r\n            merge(dest[p], src[p]);\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n},{\"../util\":43}],38:[function(require,module,exports){\nvar aggregate_1 = require('../aggregate');\r\nvar type_1 = require('../type');\r\nvar util_1 = require('../util');\r\nexports.sort = {\r\n    default: 'ascending',\r\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.ORDINAL]),\r\n    oneOf: [\r\n        {\r\n            type: 'string',\r\n            enum: ['ascending', 'descending', 'unsorted']\r\n        },\r\n        {\r\n            type: 'object',\r\n            required: ['field', 'op'],\r\n            properties: {\r\n                field: {\r\n                    type: 'string',\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                op: {\r\n                    type: 'string',\r\n                    enum: aggregate_1.AGGREGATE_OPS,\r\n                    description: 'The field name to aggregate over.'\r\n                },\r\n                order: {\r\n                    type: 'string',\r\n                    enum: ['ascending', 'descending']\r\n                }\r\n            }\r\n        }\r\n    ]\r\n};\r\n},{\"../aggregate\":9,\"../type\":42,\"../util\":43}],39:[function(require,module,exports){\nvar aggregate_1 = require('./aggregate');\r\nvar timeunit_1 = require('./timeunit');\r\nvar type_1 = require('./type');\r\nvar vlEncoding = require('./encoding');\r\nexports.DELIM = '|';\r\nexports.ASSIGN = '=';\r\nexports.TYPE = ',';\r\nexports.FUNC = '_';\r\nfunction shorten(spec) {\r\n    return 'mark' + exports.ASSIGN + spec.marktype +\r\n        exports.DELIM + shortenEncoding(spec.encoding);\r\n}\r\nexports.shorten = shorten;\r\nfunction parse(shorthand, data, config) {\r\n    var split = shorthand.split(exports.DELIM), marktype = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));\r\n    var spec = {\r\n        marktype: marktype,\r\n        encoding: encoding\r\n    };\r\n    if (data !== undefined) {\r\n        spec.data = data;\r\n    }\r\n    if (config !== undefined) {\r\n        spec.config = config;\r\n    }\r\n    return spec;\r\n}\r\nexports.parse = parse;\r\nfunction shortenEncoding(encoding) {\r\n    return vlEncoding.map(encoding, function (fieldDef, channel) {\r\n        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);\r\n    }).join(exports.DELIM);\r\n}\r\nexports.shortenEncoding = shortenEncoding;\r\nfunction parseEncoding(encodingShorthand) {\r\n    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {\r\n        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];\r\n        m[enctype] = parseFieldDef(fieldDefShorthand);\r\n        return m;\r\n    }, {});\r\n}\r\nexports.parseEncoding = parseEncoding;\r\nfunction shortenFieldDef(fieldDef) {\r\n    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +\r\n        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +\r\n        (fieldDef.bin ? 'bin' + exports.FUNC : '') +\r\n        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];\r\n}\r\nexports.shortenFieldDef = shortenFieldDef;\r\nfunction shortenFieldDefs(fieldDefs, delim) {\r\n    if (delim === void 0) { delim = exports.DELIM; }\r\n    return fieldDefs.map(shortenFieldDef).join(delim);\r\n}\r\nexports.shortenFieldDefs = shortenFieldDefs;\r\nfunction parseFieldDef(fieldDefShorthand) {\r\n    var split = fieldDefShorthand.split(exports.TYPE), i;\r\n    var fieldDef = {\r\n        field: split[0].trim(),\r\n        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]\r\n    };\r\n    for (i in aggregate_1.AGGREGATE_OPS) {\r\n        var a = aggregate_1.AGGREGATE_OPS[i];\r\n        if (fieldDef.field.indexOf(a + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(a.length + 1);\r\n            if (a === 'count' && fieldDef.field.length === 0)\r\n                fieldDef.field = '*';\r\n            fieldDef.aggregate = a;\r\n            break;\r\n        }\r\n    }\r\n    for (i in timeunit_1.TIMEUNITS) {\r\n        var tu = timeunit_1.TIMEUNITS[i];\r\n        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\r\n            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\r\n            fieldDef.timeUnit = tu;\r\n            break;\r\n        }\r\n    }\r\n    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\r\n        fieldDef.field = fieldDef.field.substr(4);\r\n        fieldDef.bin = true;\r\n    }\r\n    return fieldDef;\r\n}\r\nexports.parseFieldDef = parseFieldDef;\r\n},{\"./aggregate\":9,\"./encoding\":24,\"./timeunit\":41,\"./type\":42}],40:[function(require,module,exports){\nvar vlEncoding = require('./encoding');\r\nvar util_1 = require('./util');\r\nvar Model_1 = require('./compiler/Model');\r\nvar channel_1 = require('./channel');\r\nvar marktype_1 = require('./marktype');\r\nfunction alwaysNoOcclusion(spec) {\r\n    return vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.alwaysNoOcclusion = alwaysNoOcclusion;\r\nfunction getCleanSpec(spec) {\r\n    return new Model_1.Model(spec).toSpec(true);\r\n}\r\nexports.getCleanSpec = getCleanSpec;\r\nfunction isStack(spec) {\r\n    return (spec.encoding[channel_1.COLOR].field || spec.encoding[channel_1.DETAIL].field) &&\r\n        (spec.marktype === marktype_1.BAR || spec.marktype === marktype_1.AREA) &&\r\n        (!spec.config || !spec.config.stack !== false) &&\r\n        vlEncoding.isAggregate(spec.encoding);\r\n}\r\nexports.isStack = isStack;\r\nfunction transpose(spec) {\r\n    var oldenc = spec.encoding, encoding = util_1.duplicate(spec.encoding);\r\n    encoding.x = oldenc.y;\r\n    encoding.y = oldenc.x;\r\n    encoding.row = oldenc.column;\r\n    encoding.column = oldenc.row;\r\n    spec.encoding = encoding;\r\n    return spec;\r\n}\r\nexports.transpose = transpose;\r\n},{\"./channel\":11,\"./compiler/Model\":12,\"./encoding\":24,\"./marktype\":26,\"./util\":43}],41:[function(require,module,exports){\nexports.TIMEUNITS = [\r\n    'year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'\r\n];\r\n},{}],42:[function(require,module,exports){\nexports.QUANTITATIVE = 'quantitative';\r\nexports.ORDINAL = 'ordinal';\r\nexports.TEMPORAL = 'temporal';\r\nexports.NOMINAL = 'nominal';\r\nexports.SHORT_TYPE = {\r\n    quantitative: 'Q',\r\n    temporal: 'T',\r\n    nominal: 'N',\r\n    ordinal: 'O'\r\n};\r\nexports.TYPE_FROM_SHORT_TYPE = {\r\n    Q: exports.QUANTITATIVE,\r\n    T: exports.TEMPORAL,\r\n    O: exports.ORDINAL,\r\n    N: exports.NOMINAL\r\n};\r\nfunction getFullName(type) {\r\n    return exports.TYPE_FROM_SHORT_TYPE[type.toUpperCase()] ||\r\n        type.toLowerCase();\r\n}\r\nexports.getFullName = getFullName;\r\n},{}],43:[function(require,module,exports){\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n__export(require('datalib/src/util'));\r\n__export(require('datalib/src/generate'));\r\n__export(require('datalib/src/stats'));\r\nfunction contains(array, item) {\r\n    return array.indexOf(item) > -1;\r\n}\r\nexports.contains = contains;\r\nfunction forEach(obj, f, thisArg) {\r\n    if (obj.forEach) {\r\n        obj.forEach.call(thisArg, f);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            f.call(thisArg, obj[k], k, obj);\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\nfunction reduce(obj, f, init, thisArg) {\r\n    if (obj.reduce) {\r\n        return obj.reduce.call(thisArg, f, init);\r\n    }\r\n    else {\r\n        for (var k in obj) {\r\n            init = f.call(thisArg, init, obj[k], k, obj);\r\n        }\r\n        return init;\r\n    }\r\n}\r\nexports.reduce = reduce;\r\nfunction map(obj, f, thisArg) {\r\n    if (obj.map) {\r\n        return obj.map.call(thisArg, f);\r\n    }\r\n    else {\r\n        var output = [];\r\n        for (var k in obj) {\r\n            output.push(f.call(thisArg, obj[k], k, obj));\r\n        }\r\n        return output;\r\n    }\r\n}\r\nexports.map = map;\r\nfunction any(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (f(arr[k], k, i++))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nexports.any = any;\r\nfunction all(arr, f) {\r\n    var i = 0, k;\r\n    for (k in arr) {\r\n        if (!f(arr[k], k, i++))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nexports.all = all;\r\nvar dlBin = require('datalib/src/bins/bins');\r\nfunction getbins(stats, maxbins) {\r\n    return dlBin({\r\n        min: stats.min,\r\n        max: stats.max,\r\n        maxbins: maxbins\r\n    });\r\n}\r\nexports.getbins = getbins;\r\nfunction error(message) {\r\n    console.error('[VL Error]', message);\r\n}\r\nexports.error = error;\r\n},{\"datalib/src/bins/bins\":3,\"datalib/src/generate\":4,\"datalib/src/stats\":6,\"datalib/src/util\":8}],44:[function(require,module,exports){\nvar util_1 = require('./util');\r\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\r\n    text: ['text'],\r\n    line: ['x', 'y'],\r\n    area: ['x', 'y']\r\n};\r\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\r\n    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\r\n    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\r\n    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])\r\n};\r\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\r\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\r\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\r\n    var marktype = spec.marktype;\r\n    var encoding = spec.encoding;\r\n    var requiredChannels = requiredChannelMap[marktype];\r\n    var supportedChannels = supportedChannelMap[marktype];\r\n    for (var i in requiredChannels) {\r\n        if (!(requiredChannels[i] in encoding)) {\r\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\r\n                '\\\" for marktype \\\"' + marktype + '\\\"';\r\n        }\r\n    }\r\n    for (var channel in encoding) {\r\n        if (!supportedChannels[channel]) {\r\n            return 'Encoding channel \\\"' + channel +\r\n                '\\\" is not supported by mark type \\\"' + marktype + '\\\"';\r\n        }\r\n    }\r\n    if (marktype === 'bar' && !encoding.x && !encoding.y) {\r\n        return 'Missing both x and y for bar';\r\n    }\r\n    return null;\r\n}\r\nexports.getEncodingMappingError = getEncodingMappingError;\r\n},{\"./util\":43}],45:[function(require,module,exports){\nvar vlBin = require('./bin');\r\nvar vlChannel = require('./channel');\r\nvar vlData = require('./data');\r\nvar vlEncoding = require('./encoding');\r\nvar vlFieldDef = require('./fielddef');\r\nvar vlCompiler = require('./compiler/compiler');\r\nvar vlSchema = require('./schema/schema');\r\nvar vlShorthand = require('./shorthand');\r\nvar vlSpec = require('./spec');\r\nvar vlTimeUnit = require('./timeunit');\r\nvar vlType = require('./type');\r\nvar vlValidate = require('./validate');\r\nvar vlUtil = require('./util');\r\nexports.bin = vlBin;\r\nexports.channel = vlChannel;\r\nexports.compiler = vlCompiler;\r\nexports.compile = vlCompiler.compile;\r\nexports.data = vlData;\r\nexports.encoding = vlEncoding;\r\nexports.fieldDef = vlFieldDef;\r\nexports.schema = vlSchema;\r\nexports.shorthand = vlShorthand;\r\nexports.spec = vlSpec;\r\nexports.timeUnit = vlTimeUnit;\r\nexports.type = vlType;\r\nexports.util = vlUtil;\r\nexports.validate = vlValidate;\r\nexports.version = '0.9.0';\r\n},{\"./bin\":10,\"./channel\":11,\"./compiler/compiler\":14,\"./data\":23,\"./encoding\":24,\"./fielddef\":25,\"./schema/schema\":36,\"./shorthand\":39,\"./spec\":40,\"./timeunit\":41,\"./type\":42,\"./util\":43,\"./validate\":44}]},{},[45])(45)\n});\n\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.0.7\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","export const AGGREGATE_OPS = [\r\n  'values', 'count', 'valid', 'missing', 'distinct',\r\n  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\r\n  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\r\n  'argmin', 'argmax'\r\n];\r\n\r\nexport const SHARED_DOMAIN_OPS = [\r\n  'mean', 'average', 'stdev', 'stdevp', 'median', 'q1', 'q3', 'min', 'max'\r\n];\r\n\r\n// TODO: move supportedTypes, supportedEnums from schema to here\r\n","export const MAXBINS_DEFAULT = 15;\r\n","/*\r\n * Constants and utilities for encoding channels (Visual variables)\r\n * such as 'x', 'y', 'color'.\r\n */\r\n\r\nexport const X = 'x';\r\nexport const Y = 'y';\r\nexport const ROW = 'row';\r\nexport const COLUMN = 'column';\r\nexport const SHAPE = 'shape';\r\nexport const SIZE = 'size';\r\nexport const COLOR = 'color';\r\nexport const TEXT = 'text';\r\nexport const DETAIL = 'detail';\r\n\r\nexport const CHANNELS = [X, Y, ROW, COLUMN, SIZE, SHAPE, COLOR, TEXT, DETAIL];\r\n\r\nexport type Channel = string;\r\n\r\ninterface SupportedMarktype {\r\n  [marktype: string]: boolean;\r\n};\r\n\r\nexport function supportMarktype(channel: Channel, marktype) {\r\n  return !!getSupportedMarktype(channel)[marktype];\r\n}\r\n\r\n/**\r\n * Return a dictionary showing whether a channel supports mark type.\r\n * @param  {Enctype.Type}  channel\r\n * @return {SupportedRole} A dictionary mapping mark types to boolean values.\r\n */\r\nexport function getSupportedMarktype(channel: Channel): SupportedMarktype {\r\n  switch (channel) {\r\n    case X:\r\n    case Y:\r\n      return {\r\n        point: true, tick: true, circle: true, square: true ,\r\n        bar: true, line: true, area: true\r\n      };\r\n    case ROW:\r\n    case COLUMN:\r\n      return {\r\n        point: true, tick: true, circle: true, square: true,\r\n        bar: true, line: true, area: true, text: true\r\n      };\r\n    case SIZE:\r\n      return {\r\n        point: true, tick: true, circle: true, square: true,\r\n        bar: true, text: true\r\n      };\r\n    case COLOR:\r\n    case DETAIL:\r\n      return {\r\n        point: true, tick: true, circle: true, square: true,\r\n        bar: true, line: true, area: true, text: true\r\n      };\r\n    case SHAPE:\r\n      return {point: true};\r\n    case TEXT:\r\n      return {text: true};\r\n  }\r\n  return {};\r\n}\r\n\r\ninterface SupportedRole {\r\n  [role:string]:boolean;\r\n};\r\n\r\n/**\r\n * Return whether a channel supports dimension / measure role\r\n * @param  {Enctype.Type}  channel\r\n * @return {SupportedRole} A dictionary mapping role to boolean values.\r\n */\r\nexport function getSupportedRole(channel: Channel): SupportedRole {\r\n  switch (channel) {\r\n    case X:\r\n    case Y:\r\n    case COLOR:\r\n      return {\r\n        measure: true,\r\n        dimension: true\r\n      };\r\n    case ROW:\r\n    case COLUMN:\r\n    case SHAPE:\r\n    case DETAIL:\r\n      return {\r\n        measure: false,\r\n        dimension: true\r\n      };\r\n    case SIZE:\r\n    case TEXT:\r\n      return {\r\n        measure: true,\r\n        dimension: false\r\n      };\r\n  }\r\n  throw new Error('Invalid encoding channel' + channel);\r\n}\r\n","import {Spec} from '../schema/schema';\r\nimport {Bin} from '../schema/bin.schema';\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\n\r\nimport {MAXBINS_DEFAULT} from '../bin';\r\nimport {COLUMN, ROW, X, Y, COLOR, DETAIL, Channel} from '../channel';\r\nimport {SOURCE, SUMMARY} from '../data';\r\nimport * as vlFieldDef from '../fielddef';\r\nimport * as vlEncoding from '../encoding';\r\nimport {compileLayout} from './layout';\r\nimport {AREA, BAR} from '../marktype';\r\nimport * as schema from '../schema/schema';\r\nimport * as schemaUtil from '../schema/schemautil';\r\nimport {StackProperties} from './stack';\r\nimport {getFullName, NOMINAL, ORDINAL, TEMPORAL} from '../type';\r\nimport {contains, duplicate} from '../util';\r\nimport * as time from './time';\r\n\r\n\r\ninterface FieldRefOption {\r\n  /** exclude bin, aggregate, timeUnit */\r\n  nofn?: boolean;\r\n  /** exclude aggregation function */\r\n  noAggregate?: boolean;\r\n  /** include 'datum.' */\r\n  datum?: boolean;\r\n  /** replace fn with custom function prefix */\r\n  fn?: string;\r\n  /** prepend fn with custom function prefix */\r\n  prefn?: string;\r\n  /** append suffix to the field ref for bin (default='_start') */\r\n  binSuffix?: string;\r\n}\r\n\r\n\r\n/**\r\n * Internal model of Vega-Lite specification for the compiler.\r\n */\r\n\r\nexport class Model {\r\n  _spec: Spec;\r\n  _stack: StackProperties;\r\n  _layout: any;\r\n\r\n  // TODO: include _stack, _layout, _style, etc.\r\n\r\n  constructor(spec: Spec, theme?) {\r\n    var defaults = schema.instantiate();\r\n    this._spec = schemaUtil.merge(defaults, theme || {}, spec);\r\n\r\n    // convert short type to full type\r\n    vlEncoding.forEach(this._spec.encoding, function(fieldDef: FieldDef, channel: Channel) {\r\n      if (fieldDef.type) {\r\n        fieldDef.type = getFullName(fieldDef.type);\r\n      }\r\n    });\r\n\r\n    // calculate stack\r\n    this._stack = this.getStackProperties();\r\n    this._layout = compileLayout(this);\r\n  }\r\n\r\n  private getStackProperties(): StackProperties {\r\n    var stackChannel = (this.has(COLOR)) ? COLOR : (this.has(DETAIL)) ? DETAIL : null;\r\n\r\n    if (stackChannel &&\r\n        (this.is(BAR) || this.is(AREA)) &&\r\n        this.config('stack') !== false &&\r\n        this.isAggregate()) {\r\n      var isXMeasure = this.isMeasure(X);\r\n      var isYMeasure = this.isMeasure(Y);\r\n\r\n      if (isXMeasure && !isYMeasure) {\r\n        return {\r\n          groupbyChannel: Y,\r\n          fieldChannel: X,\r\n          stackChannel: stackChannel,\r\n          config: this.config('stack')\r\n        };\r\n      } else if (isYMeasure && !isXMeasure) {\r\n        return {\r\n          groupbyChannel: X,\r\n          fieldChannel: Y,\r\n          stackChannel: stackChannel,\r\n          config: this.config('stack')\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  layout(): any {\r\n    return this._layout;\r\n  }\r\n\r\n  stack(): StackProperties {\r\n    return this._stack;\r\n  }\r\n\r\n  toSpec(excludeConfig?, excludeData?) {\r\n    var encoding = duplicate(this._spec.encoding),\r\n      spec: any;\r\n\r\n    spec = {\r\n      marktype: this._spec.marktype,\r\n      encoding: encoding\r\n    };\r\n\r\n    if (!excludeConfig) {\r\n      spec.config = duplicate(this._spec.config);\r\n    }\r\n\r\n    if (!excludeData) {\r\n      spec.data = duplicate(this._spec.data);\r\n    }\r\n\r\n    // remove defaults\r\n    var defaults = schema.instantiate();\r\n    return schemaUtil.subtract(spec, defaults);\r\n  }\r\n\r\n  marktype() {\r\n    return this._spec.marktype;\r\n  }\r\n\r\n  is(m) {\r\n    return this._spec.marktype === m;\r\n  }\r\n\r\n  has(channel: Channel) {\r\n    // equivalent to calling vlenc.has(this._spec.encoding, channel)\r\n    return this._spec.encoding[channel].field !== undefined;\r\n  }\r\n\r\n  fieldDef(channel: Channel): FieldDef {\r\n    return this._spec.encoding[channel];\r\n  }\r\n\r\n  // get \"field\" reference for vega\r\n  field(channel: Channel, opt?: FieldRefOption) {\r\n    opt = opt || {};\r\n\r\n    const fieldDef = this.fieldDef(channel);\r\n\r\n    var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''),\r\n      field = fieldDef.field;\r\n\r\n    if (vlFieldDef.isCount(fieldDef)) {\r\n      return f + 'count';\r\n    } else if (opt.fn) {\r\n      return f + opt.fn + '_' + field;\r\n    } else if (!opt.nofn && fieldDef.bin) {\r\n      var binSuffix = opt.binSuffix || '_start';\r\n      return f + 'bin_' + field + binSuffix;\r\n    } else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\r\n      return f + fieldDef.aggregate + '_' + field;\r\n    } else if (!opt.nofn && fieldDef.timeUnit) {\r\n      return f + fieldDef.timeUnit + '_' + field;\r\n    }  else {\r\n      return f + field;\r\n    }\r\n  }\r\n\r\n  fieldTitle(channel: Channel) {\r\n    if (vlFieldDef.isCount(this._spec.encoding[channel])) {\r\n      return vlFieldDef.COUNT_DISPLAYNAME;\r\n    }\r\n    var fn = this._spec.encoding[channel].aggregate || this._spec.encoding[channel].timeUnit || (this._spec.encoding[channel].bin && 'bin');\r\n    if (fn) {\r\n      return fn.toUpperCase() + '(' + this._spec.encoding[channel].field + ')';\r\n    } else {\r\n      return this._spec.encoding[channel].field;\r\n    }\r\n  }\r\n\r\n  // returns false if binning is disabled, otherwise an object with binning properties\r\n  bin(channel: Channel): Bin | boolean {\r\n    var bin = this._spec.encoding[channel].bin;\r\n    if (bin === {})\r\n      return false;\r\n    if (bin === true)\r\n      return {\r\n        maxbins: MAXBINS_DEFAULT\r\n      };\r\n    return bin;\r\n  }\r\n\r\n  numberFormat = function(channel?: Channel) {\r\n    // TODO(#497): have different number format based on numberType (discrete/continuous)\r\n    return this.config('numberFormat');\r\n  };\r\n\r\n  map(f) {\r\n    return vlEncoding.map(this._spec.encoding, f);\r\n  }\r\n\r\n  reduce(f, init) {\r\n    return vlEncoding.reduce(this._spec.encoding, f, init);\r\n  }\r\n\r\n  forEach(f) {\r\n    return vlEncoding.forEach(this._spec.encoding, f);\r\n  }\r\n\r\n  isOrdinalScale(channel: Channel) {\r\n    const fieldDef = this.fieldDef(channel);\r\n    return fieldDef && (\r\n      contains([NOMINAL, ORDINAL], fieldDef.type) ||\r\n      ( fieldDef.type === TEMPORAL && fieldDef.timeUnit &&\r\n        time.scale.type(fieldDef.timeUnit, channel) === 'ordinal' )\r\n    );\r\n  }\r\n\r\n  isDimension(channel: Channel) {\r\n    return this.has(channel) &&\r\n      vlFieldDef.isDimension(this.fieldDef(channel));\r\n  }\r\n\r\n  isMeasure(channel: Channel) {\r\n    return this.has(channel) &&\r\n      vlFieldDef.isMeasure(this.fieldDef(channel));\r\n  }\r\n\r\n  isAggregate() {\r\n    return vlEncoding.isAggregate(this._spec.encoding);\r\n  }\r\n\r\n  isFacet() {\r\n    return this.has(ROW) || this.has(COLUMN);\r\n  }\r\n\r\n  dataTable() {\r\n    return this.isAggregate() ? SUMMARY : SOURCE;\r\n  }\r\n\r\n  data() {\r\n    return this._spec.data;\r\n  }\r\n\r\n  // returns whether the encoding has values embedded\r\n  hasValues() {\r\n    var vals = this.data().values;\r\n    return vals && vals.length;\r\n  }\r\n\r\n  config(name: string) {\r\n    return this._spec.config[name];\r\n  }\r\n}\r\n","import {Model} from './Model';\r\nimport {contains, extend, truncate} from '../util';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\r\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\r\nimport * as time from './time';\r\n\r\n// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\r\ndeclare var exports;\r\n\r\nexport function compileAxis(channel: Channel, model: Model) {\r\n  var isCol = channel === COLUMN,\r\n    isRow = channel === ROW,\r\n    type = isCol ? 'x' : isRow ? 'y': channel;\r\n\r\n  // TODO: rename def to axisDef and avoid side effects where possible.\r\n  // TODO: replace any with Vega Axis Interface\r\n  var def:any = {\r\n    type: type,\r\n    scale: channel\r\n  };\r\n\r\n  // 1. Add properties\r\n  [\r\n    // a) properties with special rules (so it has axis[property] methods) -- call rule functions\r\n    'format', 'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'title',\r\n    // b) properties without rules, only produce default values in the schema, or explicit value if specified\r\n    'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'tickSizeEnd',\r\n    'titleOffset', 'values', 'subdivide'\r\n  ].forEach(function(property) {\r\n    let method: (model: Model, channel: Channel, def:any)=>any;\r\n\r\n    var value = (method = exports[property]) ?\r\n                  // calling axis.format, axis.grid, ...\r\n                  method(model, channel, def) :\r\n                  model.fieldDef(channel).axis[property];\r\n    if (value !== undefined) {\r\n      def[property] = value;\r\n    }\r\n  });\r\n\r\n  // 2) Add mark property definition groups\r\n  var props = model.fieldDef(channel).axis.properties || {};\r\n\r\n  [\r\n    'axis', 'labels',// have special rules\r\n    'grid', 'title', 'ticks', 'majorTicks', 'minorTicks' // only default values\r\n  ].forEach(function(group) {\r\n    var value = properties[group] ?\r\n      properties[group](model, channel, props[group], def) :\r\n      props[group];\r\n    if (value !== undefined) {\r\n      def.properties = def.properties || {};\r\n      def.properties[group] = value;\r\n    }\r\n  });\r\n\r\n  return def;\r\n}\r\n\r\nexport function format(model: Model, channel: Channel) {\r\n  const fieldDef = model.fieldDef(channel);\r\n  var format = fieldDef.axis.format;\r\n  if (format !== undefined)  {\r\n    return format;\r\n  }\r\n\r\n  if (fieldDef.type === QUANTITATIVE) {\r\n    return model.numberFormat(channel);\r\n  } else if (fieldDef.type === TEMPORAL) {\r\n    const timeUnit = fieldDef.timeUnit;\r\n    if (!timeUnit) {\r\n      return model.config('timeFormat');\r\n    } else if (timeUnit === 'year') {\r\n      return 'd';\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function grid(model: Model, channel: Channel) {\r\n  const fieldDef = model.fieldDef(channel);\r\n  var grid = fieldDef.axis.grid;\r\n  if (grid !== undefined) {\r\n    return grid;\r\n  }\r\n\r\n  // If `grid` is unspecified, the default value is `true` for ordinal scales\r\n  // that are not binned\r\n  return !model.isOrdinalScale(channel) && !fieldDef.bin;\r\n}\r\n\r\nexport function layer(model: Model, channel: Channel, def) {\r\n  var layer = model.fieldDef(channel).axis.layer;\r\n  if (layer !== undefined) {\r\n    return layer;\r\n  }\r\n  if (def.grid) {\r\n    // if grid is true, need to put layer on the back so that grid is behind marks\r\n    return 'back';\r\n  }\r\n  return undefined; // otherwise return undefined and use Vega's default.\r\n};\r\n\r\nexport function offset(model: Model, channel: Channel, def) {\r\n  const offset = model.fieldDef(channel).axis.offset;\r\n  if (offset) {\r\n    return offset;\r\n  }\r\n  if ((channel === ROW && !model.has(Y)) ||\r\n      (channel === COLUMN && !model.has(X))\r\n    ) {\r\n    return model.config('cell').gridOffset;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function orient(model: Model, channel: Channel) {\r\n  var orient = model.fieldDef(channel).axis.orient;\r\n  if (orient) {\r\n    return orient;\r\n  } else if (channel === COLUMN) {\r\n    // FIXME test and decide\r\n    return 'top';\r\n  } else if (channel === ROW) {\r\n    if (model.has(Y) && model.fieldDef(Y).axis.orient !== 'right') {\r\n      return 'right';\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function ticks(model: Model, channel: Channel) {\r\n  const ticks = model.fieldDef(channel).axis.ticks;\r\n  if (ticks !== undefined) {\r\n    return ticks;\r\n  }\r\n\r\n  // FIXME depends on scale type too\r\n  if (channel === X && !model.fieldDef(channel).bin) {\r\n    return 5;\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function tickSize(model: Model, channel: Channel) {\r\n  const tickSize = model.fieldDef(channel).axis.tickSize;\r\n  if (tickSize !== undefined) {\r\n    return tickSize;\r\n  }\r\n  if (channel === ROW || channel === COLUMN) {\r\n    return 0;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function title(model: Model, channel: Channel) {\r\n  var axisSpec = model.fieldDef(channel).axis;\r\n  if (axisSpec.title !== undefined) {\r\n    return axisSpec.title;\r\n  }\r\n\r\n  // if not defined, automatically determine axis title from field def\r\n  var fieldTitle = model.fieldTitle(channel);\r\n  const layout = model.layout();\r\n\r\n  var maxLength;\r\n  if (axisSpec.titleMaxLength) {\r\n    maxLength = axisSpec.titleMaxLength;\r\n  } else if (channel === X && typeof layout.cellWidth === 'number') {\r\n    // Guess max length if we know cell size at compile time\r\n    maxLength = layout.cellWidth / model.config('characterWidth');\r\n  } else if (channel === Y && typeof layout.cellHeight === 'number') {\r\n    // Guess max length if we know cell size at compile time\r\n    maxLength = layout.cellHeight / model.config('characterWidth');\r\n  }\r\n\r\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\r\n}\r\n\r\nnamespace properties {\r\n  export function axis(model: Model, channel: Channel, spec) {\r\n    if (channel === ROW || channel === COLUMN) {\r\n      // hide axis for facets\r\n      return extend({\r\n        opacity: {value: 0}\r\n      }, spec || {});\r\n    }\r\n    return spec || undefined;\r\n  }\r\n\r\n  export function labels(model: Model, channel: Channel, spec, def) {\r\n    let fieldDef = model.fieldDef(channel);\r\n    var filterName = time.labelTemplate(fieldDef.timeUnit, fieldDef.axis.shortTimeNames);\r\n    if (fieldDef.type === TEMPORAL && filterName) {\r\n      spec = extend({\r\n        text: {template: '{{datum.data | ' + filterName + '}}'}\r\n      }, spec || {});\r\n    }\r\n\r\n    if (contains([NOMINAL, ORDINAL], fieldDef.type) && fieldDef.axis.labelMaxLength) {\r\n      // TODO replace this with Vega's labelMaxLength once it is introduced\r\n      spec = extend({\r\n        text: {\r\n          template: '{{ datum.data | truncate:' + fieldDef.axis.labelMaxLength + '}}'\r\n        }\r\n      }, spec || {});\r\n    }\r\n\r\n     // for x-axis, set ticks for Q or rotate scale for ordinal scale\r\n    switch (channel) {\r\n      case X:\r\n        if (model.isDimension(X) || fieldDef.type === TEMPORAL) {\r\n          spec = extend({\r\n            angle: {value: 270},\r\n            align: {value: def.orient === 'top' ? 'left': 'right'},\r\n            baseline: {value: 'middle'}\r\n          }, spec || {});\r\n        }\r\n        break;\r\n      case ROW:\r\n        if (def.orient === 'right') {\r\n          spec = extend({\r\n            angle: {value: 90},\r\n            align: {value: 'center'},\r\n            baseline: {value: 'bottom'}\r\n          }, spec || {});\r\n        }\r\n    }\r\n\r\n    return spec || undefined;\r\n  }\r\n}\r\n","/**\r\n * Module for compiling Vega-lite spec into Vega spec.\r\n */\r\nimport {Model} from './Model';\r\n\r\nimport {compileAxis} from './axis';\r\nimport {compileData} from './data';\r\nimport {facetMixins} from './facet';\r\nimport {compileLegends} from './legend';\r\nimport {compileMarks} from './marks';\r\nimport {compileScales} from './scale';\r\nimport * as vlTime from './time';\r\nimport {extend} from '../util';\r\n\r\nimport {LAYOUT} from '../data';\r\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\n\r\nexport {Model} from './Model';\r\n\r\nexport function compile(spec, theme?) {\r\n  var model = new Model(spec, theme);\r\n  const layout = model.layout();\r\n\r\n  var rootGroup:any = {\r\n    name: 'root',\r\n    type: 'group',\r\n    from: {data: LAYOUT},\r\n    properties: {\r\n      update: {\r\n        width: layout.width.field ?\r\n               {field: layout.width.field} :\r\n               {value: layout.width},\r\n        height: layout.height.field ?\r\n                {field: layout.height.field} :\r\n                {value: layout.height}\r\n      }\r\n    }\r\n  };\r\n\r\n  const marks = compileMarks(model);\r\n\r\n  // Small Multiples\r\n  if (model.has(ROW) || model.has(COLUMN)) {\r\n    // put the marks inside a facet cell's group\r\n    extend(rootGroup, facetMixins(model, marks));\r\n  } else {\r\n    rootGroup.marks = marks.map(function(marks) {\r\n      marks.from = marks.from || {};\r\n      marks.from.data = model.dataTable();\r\n      return marks;\r\n    });\r\n    const scaleNames = model.map(function(_, channel: Channel){\r\n        return channel; // TODO model.scaleName(channel)\r\n      });\r\n    rootGroup.scales = compileScales(scaleNames, model);\r\n\r\n    var axes = (model.has(X) ? [compileAxis(X, model)] : [])\r\n      .concat(model.has(Y) ? [compileAxis(Y, model)] : []);\r\n    if (axes.length > 0) {\r\n      rootGroup.axes = axes;\r\n    }\r\n  }\r\n\r\n  // legends (similar for either facets or non-facets\r\n  var legends = compileLegends(model);\r\n  if (legends.length > 0) {\r\n    rootGroup.legends = legends;\r\n  }\r\n\r\n  // FIXME replace FIT with appropriate mechanism once Vega has it\r\n  const FIT = 1;\r\n  // TODO: change type to become VgSpec\r\n  var output = {\r\n      width: layout.width.field ? FIT : layout.width,\r\n      height: layout.height.field ? FIT : layout.height,\r\n      padding: 'auto',\r\n      data: compileData(model),\r\n      marks: [rootGroup]\r\n    };\r\n\r\n  return {\r\n    spec: output\r\n    // TODO: add warning / errors here\r\n  };\r\n}\r\n","import * as vlFieldDef from '../fielddef';\r\nimport * as util from '../util';\r\nimport {Model} from './Model';\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\nimport {StackProperties} from './stack';\r\n\r\nimport {MAXBINS_DEFAULT} from '../bin';\r\nimport {Channel, X, Y, ROW, COLUMN} from '../channel';\r\nimport {SOURCE, STACKED, LAYOUT, SUMMARY} from '../data';\r\nimport * as time from './time';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\r\n\r\n/**\r\n * Create Vega's data array from a given encoding.\r\n *\r\n * @param  {Encoding} encoding\r\n * @return {Array} Array of Vega data.\r\n *                 This always includes a \"source\" data table.\r\n *                 If the encoding contains aggregate value, this will also create\r\n *                 aggregate table as well.\r\n */\r\nexport function compileData(model: Model) {\r\n  var def = [source.def(model)];\r\n\r\n  const summaryDef = summary.def(model);\r\n  if (summaryDef) {\r\n    def.push(summaryDef);\r\n  }\r\n\r\n  // TODO add \"having\" filter here\r\n\r\n  // append non-positive filter at the end for the data table\r\n  filterNonPositiveForLog(def[def.length - 1], model);\r\n\r\n  // add stats for layout calculation\r\n  const statsDef = layout.def(model);\r\n  if(statsDef) {\r\n    def.push(statsDef);\r\n  }\r\n\r\n  // Stack\r\n  const stackDef = model.stack();\r\n  if (stackDef) {\r\n    def.push(stack.def(model, stackDef));\r\n  }\r\n\r\n  return def;\r\n}\r\n\r\n// TODO: Consolidate all Vega interface\r\ninterface VgData {\r\n  name: string;\r\n  source?: string;\r\n  values?: any;\r\n  format?: any;\r\n  url?: any;\r\n  transform?: any;\r\n}\r\n\r\nexport namespace source {\r\n  export function def(model: Model): VgData {\r\n    var source:VgData = {name: SOURCE};\r\n\r\n    // Data source (url or inline)\r\n    if (model.hasValues()) {\r\n      source.values = model.data().values;\r\n      source.format = {type: 'json'};\r\n    } else {\r\n      source.url = model.data().url;\r\n      source.format = {type: model.data().formatType};\r\n    }\r\n\r\n    // Set data's format.parse if needed\r\n    var parse = formatParse(model);\r\n    if (parse) {\r\n      source.format.parse = parse;\r\n    }\r\n\r\n    source.transform = transform(model);\r\n    return source;\r\n  }\r\n\r\n  function formatParse(model: Model) {\r\n    var parse;\r\n\r\n    model.forEach(function(fieldDef: FieldDef) {\r\n      if (fieldDef.type === TEMPORAL) {\r\n        parse = parse || {};\r\n        parse[fieldDef.field] = 'date';\r\n      } else if (fieldDef.type === QUANTITATIVE) {\r\n        if (vlFieldDef.isCount(fieldDef)) return;\r\n        parse = parse || {};\r\n        parse[fieldDef.field] = 'number';\r\n      }\r\n    });\r\n\r\n    return parse;\r\n  }\r\n\r\n  /**\r\n   * Generate Vega transforms for the source data table.  This can include\r\n   * transforms for time unit, binning and filtering.\r\n   */\r\n  export function transform(model: Model) {\r\n    // null filter comes first so transforms are not performed on null values\r\n    // time and bin should come before filter so we can filter by time and bin\r\n    return nullFilterTransform(model).concat(\r\n      formulaTransform(model),\r\n      timeTransform(model),\r\n      binTransform(model),\r\n      filterTransform(model)\r\n    );\r\n  }\r\n\r\n  export function timeTransform(model: Model) {\r\n    return model.reduce(function(transform, fieldDef: FieldDef, channel: Channel) {\r\n      if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\r\n        var field = model.field(channel, {nofn: true, datum: true});\r\n\r\n        transform.push({\r\n          type: 'formula',\r\n          field: model.field(channel),\r\n          expr: time.formula(fieldDef.timeUnit, field)\r\n        });\r\n      }\r\n      return transform;\r\n    }, []);\r\n  }\r\n\r\n  export function binTransform(model: Model) {\r\n    return model.reduce(function(transform, fieldDef: FieldDef, channel: Channel) {\r\n      const bin = model.bin(channel);\r\n      if (bin) {\r\n        transform.push({\r\n          type: 'bin',\r\n          field: fieldDef.field,\r\n          output: {\r\n            start: model.field(channel, {binSuffix: '_start'}),\r\n            mid: model.field(channel, {binSuffix: '_mid'}),\r\n            end: model.field(channel, {binSuffix: '_end'})\r\n          },\r\n          maxbins: typeof bin === 'boolean' ? MAXBINS_DEFAULT : bin.maxbins\r\n        });\r\n      }\r\n      return transform;\r\n    }, []);\r\n  }\r\n\r\n  /**\r\n   * @return {Array} An array that might contain a filter transform for filtering null value based on filterNul config\r\n   */\r\n  export function nullFilterTransform(model: Model) {\r\n    const filterNull = model.config('filterNull');\r\n    const filteredFields = util.keys(model.reduce(function(filteredFields, fieldDef: FieldDef) {\r\n      if (fieldDef.field && fieldDef.field !== '*' && filterNull[fieldDef.type]) {\r\n        filteredFields[fieldDef.field] = true;\r\n      }\r\n      return filteredFields;\r\n    }, {}));\r\n\r\n    return filteredFields.length > 0 ?\r\n      [{\r\n        type: 'filter',\r\n        test: filteredFields.map(function(fieldName) {\r\n          return 'datum.' + fieldName + '!==null';\r\n        }).join(' && ')\r\n      }] : [];\r\n  }\r\n\r\n  export function filterTransform(model: Model) {\r\n    var filter = model.data().filter;\r\n    return filter ? [{\r\n        type: 'filter',\r\n        test: filter\r\n    }] : [];\r\n  }\r\n\r\n  export function formulaTransform(model: Model) {\r\n    var calculate = model.data().calculate;\r\n    if (calculate === undefined) {\r\n      return [];\r\n    }\r\n\r\n    return calculate.reduce(function(transform, formula) {\r\n      transform.push(util.extend({type: 'formula'}, formula));\r\n      return transform;\r\n    }, []);\r\n  }\r\n}\r\n\r\nexport namespace layout {\r\n\r\n  export function def(model: Model): VgData {\r\n    let summarize = [];\r\n    let formulas = [];\r\n\r\n    // TODO: handle \"fit\" mode\r\n    if (model.has(X) && model.isOrdinalScale(X)) { // FIXME check if we need to call twice\r\n      summarize.push({\r\n        field: model.field(X),\r\n        ops: ['distinct']\r\n      });\r\n      const xScale = model.fieldDef(X).scale;\r\n      formulas.push({\r\n        type: 'formula',\r\n        field: 'cellWidth',\r\n        // (xCardinality + model.padding(X)) * xBandWidth\r\n        expr: '(' + model.field(X, {datum: true, prefn: 'distinct_'}) + ' + ' +\r\n              xScale.padding + ') * ' + xScale.bandWidth\r\n      });\r\n    }\r\n\r\n    if (model.has(Y) && model.isOrdinalScale(Y)) { // FIXME check if we need to call twice\r\n      summarize.push({\r\n        field: model.field(Y),\r\n        ops: ['distinct']\r\n      });\r\n\r\n      const yScale = model.fieldDef(Y).scale;\r\n      formulas.push({\r\n        type: 'formula',\r\n        field: 'cellHeight',\r\n        // (yCardinality + model.padding(Y)) * yBandWidth\r\n        expr: '(' + model.field(Y, {datum: true, prefn: 'distinct_'}) + ' + ' +\r\n              yScale.padding + ') * ' + yScale.bandWidth\r\n      });\r\n    }\r\n\r\n    const cellPadding = model.config('cell').padding;\r\n    const layout = model.layout();\r\n\r\n    if (model.has(COLUMN)) {\r\n      const cellWidth = layout.cellWidth.field ?\r\n                        'datum.' + layout.cellWidth.field :\r\n                        layout.cellWidth;\r\n      const distinctCol = model.field(COLUMN, {datum: true, prefn: 'distinct_'});\r\n      summarize.push({\r\n        field: model.fieldDef(COLUMN).field,\r\n        ops: ['distinct']\r\n      });\r\n      formulas.push({\r\n        type: 'formula',\r\n        field: 'width',\r\n        // cellWidth + (|col| + (|col| - 1) * cellPadding)\r\n        expr: cellWidth + ' * ' + distinctCol + ' + ' +\r\n              '(' + distinctCol + ' - 1) * ' + cellPadding\r\n      });\r\n    }\r\n\r\n    if (model.has(ROW)) {\r\n      const cellHeight = layout.cellHeight.field ?\r\n                        'datum.' + layout.cellHeight.field :\r\n                        layout.cellHeight;\r\n      const distinctRow = model.field(ROW, {datum: true, prefn: 'distinct_'});\r\n      summarize.push({\r\n        field: model.fieldDef(ROW).field,\r\n        ops: ['distinct']\r\n      });\r\n      formulas.push({\r\n        type: 'formula',\r\n        field: 'height',\r\n        // cellHeight + (|row| + (|row| - 1) * cellPadding)\r\n        expr: cellHeight + ' * ' + distinctRow + ' + ' +\r\n              '(' + distinctRow + ' - 1) * ' + cellPadding\r\n      });\r\n    }\r\n\r\n    if (summarize.length > 0) {\r\n      return {\r\n        name: LAYOUT,\r\n        source: model.dataTable(),\r\n        transform: [{\r\n            type: 'aggregate',\r\n              summarize: summarize\r\n          }].concat(formulas)\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nexport namespace summary {\r\n  export function def(model: Model):VgData {\r\n    /* dict set for dimensions */\r\n    var dims = {};\r\n\r\n    /* dictionary mapping field name => dict set of aggregation functions */\r\n    var meas = {};\r\n\r\n    var hasAggregate = false;\r\n\r\n    model.forEach(function(fieldDef, channel: Channel) {\r\n      if (fieldDef.aggregate) {\r\n        hasAggregate = true;\r\n        if (fieldDef.aggregate === 'count') {\r\n          meas['*'] = meas['*'] || {};\r\n          meas['*'].count = true;\r\n        } else {\r\n          meas[fieldDef.field] = meas[fieldDef.field] || {};\r\n          meas[fieldDef.field][fieldDef.aggregate] = true;\r\n        }\r\n      } else {\r\n        if (fieldDef.bin) {\r\n          // TODO(#694) only add dimension for the required ones.\r\n          dims[model.field(channel, {binSuffix: '_start'})] = model.field(channel, {binSuffix: '_start'});\r\n          dims[model.field(channel, {binSuffix: '_mid'})] = model.field(channel, {binSuffix: '_mid'});\r\n          dims[model.field(channel, {binSuffix: '_end'})] = model.field(channel, {binSuffix: '_end'});\r\n        } else {\r\n          dims[fieldDef.field] = model.field(channel);\r\n        }\r\n\r\n      }\r\n    });\r\n\r\n    var groupby = util.vals(dims);\r\n\r\n    // short-format summarize object for Vega's aggregate transform\r\n    // https://github.com/vega/vega/wiki/Data-Transforms#-aggregate\r\n    var summarize = util.reduce(meas, function(summarize, fnDictSet, field) {\r\n      summarize[field] = util.keys(fnDictSet);\r\n      return summarize;\r\n    }, {});\r\n\r\n    if (hasAggregate) {\r\n      return {\r\n        name: SUMMARY,\r\n        source: SOURCE,\r\n        transform: [{\r\n          type: 'aggregate',\r\n          groupby: groupby,\r\n          summarize: summarize\r\n        }]\r\n      };\r\n    }\r\n\r\n    return null;\r\n  };\r\n}\r\n\r\nexport namespace stack {\r\n  /**\r\n   * Add stacked data source, for feeding the shared scale.\r\n   */\r\n  export function def(model: Model, stackProps: StackProperties):VgData {\r\n    var groupbyChannel = stackProps.groupbyChannel;\r\n    var fieldChannel = stackProps.fieldChannel;\r\n    var facetFields = (model.has(COLUMN) ? [model.field(COLUMN)] : [])\r\n                      .concat((model.has(ROW) ? [model.field(ROW)] : []));\r\n\r\n    var stacked:VgData = {\r\n      name: STACKED,\r\n      source: model.dataTable(),\r\n      transform: [{\r\n        type: 'aggregate',\r\n        // group by channel and other facets\r\n        groupby: [model.field(groupbyChannel)].concat(facetFields),\r\n        summarize: [{ops: ['sum'], field: model.field(fieldChannel)}]\r\n      }]\r\n    };\r\n\r\n    if (facetFields && facetFields.length > 0) {\r\n      stacked.transform.push({ //calculate max for each facet\r\n        type: 'aggregate',\r\n        groupby: facetFields,\r\n        summarize: [{\r\n          ops: ['max'],\r\n          // we want max of sum from above transform\r\n          field: model.field(fieldChannel, {prefn: 'sum_'})\r\n        }]\r\n      });\r\n    }\r\n    return stacked;\r\n  };\r\n}\r\n\r\nexport function filterNonPositiveForLog(dataTable, model: Model) {\r\n  model.forEach(function(_, channel) {\r\n    if (model.fieldDef(channel).scale.type === 'log') {\r\n      dataTable.transform.push({\r\n        type: 'filter',\r\n        test: model.field(channel, {datum: true}) + ' > 0'\r\n      });\r\n    }\r\n  });\r\n}\r\n","import * as util from '../util';\r\nimport {COLUMN, ROW, X, Y, TEXT, Channel} from '../channel';\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\nimport {Model} from './Model';\r\n\r\nimport {compileAxis} from './axis';\r\nimport {compileScales} from './scale';\r\n\r\n/**\r\n * return mixins that contains marks, scales, and axes for the rootGroup\r\n */\r\nexport function facetMixins(model: Model, marks) {\r\n  const layout = model.layout();\r\n\r\n  const cellWidth: any = !model.has(COLUMN) ?\r\n      {field: {group: 'width'}} :     // cellWidth = width -- just use group's\r\n    layout.cellWidth.field ?\r\n      {scale: 'column', band: true} : // bandSize of the scale\r\n      {value: layout.cellWidth};      // static value\r\n\r\n  const cellHeight: any = !model.has(ROW) ?\r\n      {field: {group: 'height'}} :  // cellHeight = height -- just use group's\r\n    layout.cellHeight.field ?\r\n      {scale: 'row', band: true} :  // bandSize of the scale\r\n      {value: layout.cellHeight};   // static value\r\n\r\n  let facetGroupProperties: any = {\r\n    width: cellWidth,\r\n    height: cellHeight\r\n  };\r\n\r\n  // add configs that are the resulting group marks properties\r\n  const cellConfig = model.config('cell');\r\n  ['fill', 'fillOpacity', 'stroke', 'strokeWidth',\r\n    'strokeOpacity', 'strokeDash', 'strokeDashOffset']\r\n    .forEach(function(property) {\r\n      const value = cellConfig[property];\r\n      if (value !== undefined) {\r\n        facetGroupProperties[property] = value;\r\n      }\r\n    });\r\n\r\n  let rootMarks = [], rootAxes = [], facetKeys = [], cellAxes = [];\r\n  const hasRow = model.has(ROW), hasCol = model.has(COLUMN);\r\n\r\n  // TODO(#90): add property to keep axes in cells even if row is encoded\r\n  if (hasRow) {\r\n    if (!model.isDimension(ROW)) {\r\n      // TODO: add error to model instead\r\n      util.error('Row encoding should be ordinal.');\r\n    }\r\n    facetGroupProperties.y = {\r\n      scale: ROW,\r\n      field: model.field(ROW)\r\n    };\r\n\r\n    facetKeys.push(model.field(ROW));\r\n    rootAxes.push(compileAxis(ROW, model));\r\n    if (model.has(X)) {\r\n      // If has X, prepend a group for shared x-axes in the root group's marks\r\n      rootMarks.push(getXAxesGroup(model, cellWidth, hasCol));\r\n    }\r\n\r\n    // TODO: add properties to make rule optional\r\n    rootMarks.push(getRowRulesGroup(model, cellHeight));\r\n  } else { // doesn't have row\r\n    if (model.has(X)) { //keep x axis in the cell\r\n      cellAxes.push(compileAxis(X, model));\r\n    }\r\n  }\r\n\r\n  // TODO(#90): add property to keep axes in cells even if column is encoded\r\n  if (hasCol) {\r\n    if (!model.isDimension(COLUMN)) {\r\n      // TODO: add error to model instead\r\n      util.error('Col encoding should be ordinal.');\r\n    }\r\n    facetGroupProperties.x = {\r\n      scale: COLUMN,\r\n      field: model.field(COLUMN)\r\n    };\r\n\r\n    facetKeys.push(model.field(COLUMN));\r\n    rootAxes.push(compileAxis(COLUMN, model));\r\n\r\n    if (model.has(Y)) {\r\n      // If has Y, prepend a group for shared y-axes in the root group's marks\r\n      rootMarks.push(getYAxesGroup(model, cellHeight, hasRow));\r\n    }\r\n    // TODO: add properties to make rule optional\r\n    rootMarks.push(getColumnRulesGroup(model, cellWidth));\r\n  } else { // doesn't have column\r\n    if (model.has(Y)) { //keep y axis in the cell\r\n      cellAxes.push(compileAxis(Y, model));\r\n    }\r\n  }\r\n\r\n  let facetGroup: any = {\r\n    name: 'cell', // FIXME model.name() + cell\r\n    type: 'group',\r\n    from: {\r\n      data: model.dataTable(),\r\n      transform: [{type: 'facet', groupby: facetKeys}]\r\n    },\r\n    properties: {\r\n      update: facetGroupProperties\r\n    },\r\n    marks: marks\r\n  };\r\n  if (cellAxes.length > 0) {\r\n    facetGroup.axes = cellAxes;\r\n  }\r\n  rootMarks.push(facetGroup);\r\n\r\n  const scaleNames = model.map(function(_, channel: Channel){\r\n    return channel; // TODO model.scaleName(channel)\r\n  });\r\n\r\n  return {\r\n    marks: rootMarks,\r\n    axes: rootAxes,\r\n    // assuming equal cellWidth here\r\n    scales: compileScales(scaleNames, model)\r\n  };\r\n}\r\n\r\nfunction getXAxesGroup(model: Model, cellWidth, hasCol: boolean) {\r\n  let xAxesGroup: any = { // TODO: VgMarks\r\n    name: 'x-axes',\r\n    type: 'group',\r\n    properties: {\r\n      update: {\r\n        width: cellWidth,\r\n        height: {field: {group: 'height'}},\r\n        x: hasCol ? {scale: COLUMN, field: model.field(COLUMN)} : {value: 0},\r\n        y: {value: - model.config('cell').padding / 2}\r\n      }\r\n    },\r\n    axes: [compileAxis(X, model)]\r\n  };\r\n  if (hasCol) {\r\n    // FIXME facet is too expensive here - we only need to know unique columns\r\n    xAxesGroup.from = {\r\n      data: model.dataTable(),\r\n      transform: {type: 'facet', groupby: [model.field(COLUMN)]}\r\n    };\r\n  }\r\n  return xAxesGroup;\r\n}\r\n\r\nfunction getYAxesGroup(model: Model, cellHeight, hasRow: boolean) {\r\n  let yAxesGroup: any = { // TODO: VgMarks\r\n    name: 'y-axes',\r\n    type: 'group',\r\n    properties: {\r\n      update: {\r\n        width: {field: {group: 'width'}},\r\n        height: cellHeight,\r\n        x: {value: - model.config('cell').padding / 2},\r\n        y: hasRow ? {scale: ROW, field: model.field(ROW)} : {value: 0}\r\n      }\r\n    },\r\n    axes: [compileAxis(Y, model)]\r\n  };\r\n\r\n  if (hasRow) {\r\n    // FIXME facet is too expensive here - we only need to know unique rows\r\n    yAxesGroup.from = {\r\n      data: model.dataTable(),\r\n      transform: {type: 'facet', groupby: [model.field(ROW)]}\r\n    };\r\n  }\r\n  return yAxesGroup;\r\n}\r\n\r\nfunction getRowRulesGroup(model: Model, cellHeight): any { // TODO: VgMarks\r\n  const rowRulesOnTop = !model.has(X) || model.fieldDef(X).axis.orient !== 'top';\r\n  const offset = model.config('cell').padding / 2 - 1;\r\n  const rowRules = {\r\n    name: 'row-rules',\r\n    type: 'rule',\r\n    from: {\r\n      data: model.dataTable(),\r\n      transform: [{type: 'facet', groupby: [model.field(ROW)]}]\r\n    },\r\n    properties: {\r\n      update: {\r\n        y: {\r\n          scale: 'row',\r\n          field: model.field(ROW),\r\n          offset: (rowRulesOnTop ? -1 : 1) * offset\r\n        },\r\n        x: {value: 0, offset: -model.config('cell').gridOffset},\r\n        x2: {field: {group: 'width'}, offset: model.config('cell').gridOffset},\r\n        stroke: { value: model.config('cell').gridColor },\r\n        strokeOpacity: { value: model.config('cell').gridOpacity }\r\n      }\r\n    }\r\n  };\r\n\r\n  if (rowRulesOnTop) { // on top - no need to add offset\r\n    return rowRules;\r\n  } // otherwise, need to offset all rules by cellHeight\r\n  return {\r\n    name: 'row-rules-group',\r\n    type: 'group',\r\n    properties: {\r\n      update: {\r\n        // add offset to avoid clashing with axis\r\n        y: cellHeight.value ?\r\n          // If cellHeight contains value, just use it.\r\n          cellHeight :\r\n          // Otherwise, need to get it from layout data in the root group\r\n          {field: {parent: 'cellHeight'}},\r\n\r\n        // include width so it can be referred inside row-rules\r\n        width: {field: {group: 'width'}}\r\n      }\r\n    },\r\n    marks: [rowRules]\r\n  };\r\n}\r\n\r\nfunction getColumnRulesGroup(model: Model, cellWidth): any { // TODO: VgMarks\r\n  const colRulesOnLeft = !model.has(Y) || model.fieldDef(Y).axis.orient === 'right';\r\n  const offset = model.config('cell').padding / 2 - 1;\r\n  const columnRules = {\r\n    name: 'column-rules',\r\n    type: 'rule',\r\n    from: {\r\n      data: model.dataTable(),\r\n      transform: [{type: 'facet', groupby: [model.field(COLUMN)]}]\r\n    },\r\n    properties: {\r\n      update: {\r\n        x: {\r\n          scale: 'column',\r\n          field: model.field(COLUMN),\r\n          offset: (colRulesOnLeft ? -1 : 1) * offset\r\n        },\r\n        y: {value: 0, offset: -model.config('cell').gridOffset},\r\n        y2: {field: {group: 'height'}, offset: model.config('cell').gridOffset},\r\n        stroke: { value: model.config('cell').gridColor },\r\n        strokeOpacity: { value: model.config('cell').gridOpacity }\r\n      }\r\n    }\r\n  };\r\n\r\n  if (colRulesOnLeft) { // on left, no need to add global offset\r\n    return columnRules;\r\n  } // otherwise, need to offset all rules by cellWidth\r\n  return {\r\n    name: 'column-rules-group',\r\n    type: 'group',\r\n    properties: {\r\n      update: {\r\n        // Add offset to avoid clashing with axis\r\n        x: cellWidth.value ?\r\n           // If cellWidth contains value, just use it.\r\n           cellWidth :\r\n           // Otherwise, need to get it from layout data in the root group\r\n           {field: {parent: 'cellWidth'}},\r\n\r\n        // include height so it can be referred inside column-rules\r\n        height: {field: {group: 'height'}}\r\n      }\r\n    },\r\n    marks: [columnRules]\r\n  };\r\n}\r\n","import {Model} from './Model';\r\nimport * as time from './time';\r\n\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\nimport {COLUMN, ROW, X, Y, TEXT, Channel} from '../channel';\r\nimport {LAYOUT} from '../data';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE} from '../type';\r\n\r\ninterface DataRef {\r\n  data?: string;\r\n  field?: string;\r\n  value?: string;\r\n}\r\n\r\n// value that we can put in scale's domain/range (either a number, or a data ref)\r\ntype LayoutValue = number | DataRef;\r\n\r\nexport function compileLayout(model: Model): {[layoutProp: string]: LayoutValue} {\r\n  const cellWidth = getCellWidth(model);\r\n  const cellHeight = getCellHeight(model);\r\n  return {\r\n    // width and height of the whole cell\r\n    cellWidth: cellWidth,\r\n    cellHeight: cellHeight,\r\n    // width and height of the chart\r\n    width: getWidth(model, cellWidth),\r\n    height: getHeight(model, cellHeight)\r\n  };\r\n}\r\n\r\nfunction getCellWidth(model: Model): LayoutValue {\r\n  if (model.has(X)) {\r\n    if (model.isOrdinalScale(X)) { // calculate in data\r\n      return {data: LAYOUT, field: 'cellWidth'};\r\n    }\r\n    return model.config('cell').width;\r\n  }\r\n  if (model.marktype() === TEXT) {\r\n    return model.config('textCellWidth');\r\n  }\r\n  return model.fieldDef(X).scale.bandWidth;\r\n}\r\n\r\nfunction getWidth(model: Model, cellWidth: LayoutValue): LayoutValue {\r\n  if (model.has(COLUMN)) { // calculate in data\r\n    return {data: LAYOUT, field: 'width'};\r\n  }\r\n  return cellWidth;\r\n}\r\n\r\nfunction getCellHeight(model: Model): LayoutValue {\r\n  if (model.has(Y)) {\r\n    if (model.isOrdinalScale(Y)) { // calculate in data\r\n      return {data: LAYOUT, field: 'cellHeight'};\r\n    } else {\r\n      return model.config('cell').height;\r\n    }\r\n  }\r\n  return model.fieldDef(Y).scale.bandWidth;\r\n}\r\n\r\nfunction getHeight(model: Model, cellHeight: LayoutValue): LayoutValue {\r\n  if (model.has(ROW)) {\r\n    return {data: LAYOUT, field: 'height'};\r\n  }\r\n  return cellHeight;\r\n}\r\n","import {extend, keys} from '../util';\r\nimport {COLOR, SIZE, SHAPE, Channel} from '../channel';\r\nimport {Model} from './Model';\r\nimport * as time from './time';\r\nimport {TEMPORAL} from '../type';\r\n\r\nexport function compileLegends(model: Model) {\r\n  var defs = [];\r\n\r\n  if (model.has(COLOR) && model.fieldDef(COLOR).legend) {\r\n    defs.push(compileLegend(model, COLOR, {\r\n      fill: COLOR\r\n      // TODO: consider if this should be stroke for line\r\n    }));\r\n  }\r\n\r\n  if (model.has(SIZE) && model.fieldDef(SIZE).legend) {\r\n    defs.push(compileLegend(model, SIZE, {\r\n      size: SIZE\r\n    }));\r\n  }\r\n\r\n  if (model.has(SHAPE) && model.fieldDef(SHAPE).legend) {\r\n    defs.push(compileLegend(model, SHAPE, {\r\n      shape: SHAPE\r\n    }));\r\n  }\r\n  return defs;\r\n}\r\n\r\nexport function compileLegend(model: Model, channel: Channel, def) {\r\n  // https://github.com/Microsoft/TypeScript/issues/5842\r\n  const legend:any = model.fieldDef(channel).legend;\r\n\r\n  // 1.1 Add properties with special rules\r\n  def.title = title(model, channel);\r\n\r\n  // 1.2 Add properties without rules\r\n  ['orient', 'format', 'values'].forEach(function(property) {\r\n    let value = legend[property];\r\n    if (value !== undefined) {\r\n      def[property] = value;\r\n    }\r\n  });\r\n\r\n  // 2) Add mark property definition groups\r\n  const props = (typeof legend !== 'boolean' && legend.properties) || {};\r\n  ['title', 'labels', 'symbols', 'legend'].forEach(function(group) {\r\n    let value = properties[group] ?\r\n      properties[group](model, channel, props[group]) : // apply rule\r\n      props[group]; // no rule -- just default values\r\n    if (value !== undefined) {\r\n      def.properties = def.properties || {};\r\n      def.properties[group] = value;\r\n    }\r\n  });\r\n\r\n  return def;\r\n}\r\n\r\nexport function title(model: Model, channel: Channel) {\r\n  // https://github.com/Microsoft/TypeScript/issues/5842\r\n  const legend: any = model.fieldDef(channel).legend;\r\n\r\n  if (typeof legend !== 'boolean' && legend.title) {\r\n    return legend.title;\r\n  }\r\n\r\n  return model.fieldTitle(channel);\r\n}\r\n\r\nnamespace properties {\r\n  export function labels(model: Model, channel: Channel, spec) {\r\n    var fieldDef = model.fieldDef(channel);\r\n    var timeUnit = fieldDef.timeUnit;\r\n    if (fieldDef.type === TEMPORAL && timeUnit && time.labelTemplate(timeUnit)) {\r\n      return extend({\r\n        text: {\r\n          template: '{{datum.data | ' + time.labelTemplate(timeUnit) + '}}'\r\n        }\r\n      }, spec || {});\r\n    }\r\n    return spec;\r\n  }\r\n\r\n  export function symbols(model: Model, channel: Channel, spec) {\r\n    let symbols:any = {};\r\n    let marktype = model.marktype();\r\n\r\n    switch (marktype) {\r\n      case 'bar':\r\n      case 'tick':\r\n      case 'text':\r\n        symbols.stroke = {value: 'transparent'};\r\n        symbols.shape = {value: 'square'};\r\n        break;\r\n\r\n      case 'circle':\r\n      case 'square':\r\n        symbols.shape = {value: marktype};\r\n        /* fall through */\r\n      case 'point':\r\n        // fill or stroke\r\n        if (model.config('marks').filled) {\r\n          if (model.has(COLOR) && channel === COLOR) {\r\n            symbols.fill = {scale: COLOR, field: 'data'};\r\n          } else {\r\n            symbols.fill = {value: model.fieldDef(COLOR).value};\r\n          }\r\n          symbols.stroke = {value: 'transparent'};\r\n        } else {\r\n          if (model.has(COLOR) && channel === COLOR) {\r\n            symbols.stroke = {scale: COLOR, field: 'data'};\r\n          } else {\r\n            symbols.stroke = {value: model.fieldDef(COLOR).value};\r\n          }\r\n          symbols.fill = {value: 'transparent'};\r\n          symbols.strokeWidth = {value: model.config('marks').strokeWidth};\r\n        }\r\n\r\n        break;\r\n      case 'line':\r\n      case 'area':\r\n        // TODO use shape here after implementing #508\r\n        break;\r\n    }\r\n\r\n    var opacity = model.config('marks').opacity;\r\n    if (opacity) {\r\n      symbols.opacity = {value: opacity};\r\n    }\r\n\r\n    symbols = extend(symbols, spec || {});\r\n\r\n    return keys(symbols).length > 0 ? symbols : undefined;\r\n  }\r\n}\r\n","import {Model} from './Model';\r\nimport {COLUMN, ROW, X, Y, COLOR, TEXT, SIZE, SHAPE, DETAIL, Channel} from '../channel';\r\nimport {AREA, BAR, LINE, POINT, TEXT as TEXTMARKS, TICK, CIRCLE, SQUARE} from '../marktype';\r\nimport {QUANTITATIVE} from '../type';\r\nimport {imputeTransform, stackTransform} from './stack';\r\n\r\n// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\r\ndeclare var exports;\r\n\r\n/* mapping from vega-lite's mark types to vega's mark types */\r\nconst MARKTYPES_MAP = {\r\n  bar: 'rect',\r\n  tick: 'rect',\r\n  point: 'symbol',\r\n  line: 'line',\r\n  area: 'area',\r\n  text: 'text',\r\n  circle: 'symbol',\r\n  square: 'symbol'\r\n};\r\n\r\nexport function compileMarks(model: Model): any[] {\r\n  const marktype = model.marktype();\r\n  if (marktype === LINE || marktype === AREA) {\r\n    // For Line and Area, we sort values based on dimension by default\r\n    // For line, a special config \"sortLineBy\" is allowed\r\n    let sortBy = marktype === LINE ? model.config('sortLineBy') : undefined;\r\n    if (!sortBy) {\r\n      const sortField = (model.isMeasure(X) && model.isDimension(Y)) ? Y : X;\r\n      sortBy = '-' + model.field(sortField);\r\n    }\r\n\r\n    let pathMarks: any = {\r\n      type: MARKTYPES_MAP[marktype],\r\n      from: {\r\n        // from.data might be added later for non-facet, single group line/area\r\n        transform: [{type: 'sort', by: sortBy}]\r\n      },\r\n      properties: {\r\n        update: properties[marktype](model)\r\n      }\r\n    };\r\n\r\n    // FIXME is there a case where area requires impute without stacking?\r\n\r\n    const details = detailFields(model);\r\n    if (details.length > 0) { // have level of details - need to facet line into subgroups\r\n      const facetTransform = {type: 'facet', groupby: details};\r\n      const transform = marktype === AREA && model.stack() ?\r\n        // For stacked area, we need to impute missing tuples and stack values\r\n        [imputeTransform(model), stackTransform(model), facetTransform] :\r\n        [facetTransform];\r\n\r\n      return [{\r\n        name: marktype  + '-facet',\r\n        type: 'group',\r\n        from: {\r\n          // from.data might be added later for non-facet charts\r\n          transform: transform\r\n        },\r\n        properties: {\r\n          update: {\r\n            width: {field: {group: 'width'}},\r\n            height: {field: {group: 'height'}}\r\n          }\r\n        },\r\n        marks: [pathMarks]\r\n      }];\r\n    } else {\r\n      return [pathMarks];\r\n    }\r\n  } else { // other mark type\r\n    let marks = []; // TODO: vgMarks\r\n    if (marktype === TEXTMARKS && model.has(COLOR)) {\r\n      // add background to 'text' marks if has color\r\n      marks.push({\r\n        type: 'rect',\r\n        properties: {update: properties.textBackground(model)}\r\n      });\r\n    }\r\n\r\n    let mainDef: any = {\r\n      // TODO add name\r\n      type: MARKTYPES_MAP[marktype],\r\n      properties: {\r\n        update: properties[marktype](model)\r\n      }\r\n    };\r\n    const stack = model.stack();\r\n    if (marktype === BAR && stack) {\r\n      mainDef.from = {\r\n        transform: [stackTransform(model)]\r\n      };\r\n    }\r\n    marks.push(mainDef);\r\n\r\n    // if (model.has(LABEL)) {\r\n    //   // TODO: add label by type here\r\n    // }\r\n\r\n    return marks;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns list of detail fields (for 'color', 'shape', or 'detail' channels)\r\n * that the model's spec contains.\r\n */\r\nfunction detailFields(model:Model): string[] {\r\n  return [COLOR, DETAIL, SHAPE].reduce(function(details, channel) {\r\n    if (model.has(channel) && !model.fieldDef(channel).aggregate) {\r\n      details.push(model.field(channel));\r\n    }\r\n    return details;\r\n  }, []);\r\n}\r\n\r\nexport namespace properties {\r\nexport function bar(model: Model) {\r\n  const stack = model.stack();\r\n\r\n  // TODO Use Vega's marks properties interface\r\n  var p:any = {};\r\n\r\n  // x's and width\r\n  if (stack && X === stack.fieldChannel) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X) + '_start'\r\n    };\r\n    p.x2 = {\r\n      scale: X,\r\n      field: model.field(X) + '_end'\r\n    };\r\n  } else if (model.fieldDef(X).bin) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_start'}),\r\n      offset: 1\r\n    };\r\n    p.x2 = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_end'})\r\n    };\r\n  } else if (model.isMeasure(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X)\r\n    };\r\n    if (!model.has(Y) || model.isDimension(Y)) {\r\n      p.x2 = {value: 0};\r\n    }\r\n  } else {\r\n    if (model.has(X)) { // is ordinal\r\n       p.xc = {\r\n         scale: X,\r\n         field: model.field(X)\r\n       };\r\n    } else {\r\n       p.x = {value: 0, offset: model.config('singleBarOffset')};\r\n    }\r\n  }\r\n\r\n  // width\r\n  if (!p.x2) {\r\n    if (!model.has(X) || model.isOrdinalScale(X)) { // no X or X is ordinal\r\n      if (model.has(SIZE)) {\r\n        p.width = {\r\n          scale: SIZE,\r\n          field: model.field(SIZE)\r\n        };\r\n      } else {\r\n        // FIXME consider using band: true here\r\n        p.width = {\r\n          value: model.fieldDef(X).scale.bandWidth,\r\n          offset: -1\r\n        };\r\n      }\r\n    } else { // X is Quant or Time Scale\r\n      p.width = {value: 2};\r\n    }\r\n  }\r\n\r\n  // y's & height\r\n  if (stack && Y === stack.fieldChannel) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y) + '_start'\r\n    };\r\n    p.y2 = {\r\n      scale: Y,\r\n      field: model.field(Y) + '_end'\r\n    };\r\n  } else if (model.fieldDef(Y).bin) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_start'})\r\n    };\r\n    p.y2 = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_end'}),\r\n      offset: 1\r\n    };\r\n  } else if (model.isMeasure(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y)\r\n    };\r\n    p.y2 = {field: {group: 'height'}};\r\n  } else {\r\n    if (model.has(Y)) { // is ordinal\r\n      p.yc = {\r\n        scale: Y,\r\n        field: model.field(Y)\r\n      };\r\n    } else {\r\n      p.y2 = {\r\n        field: {group: 'height'},\r\n        offset: -model.config('singleBarOffset')\r\n      };\r\n    }\r\n\r\n    if (model.has(SIZE)) {\r\n      p.height = {\r\n        scale: SIZE,\r\n        field: model.field(SIZE)\r\n      };\r\n    } else {\r\n      // FIXME: band:true?\r\n      p.height = {\r\n        value: model.fieldDef(Y).scale.bandWidth,\r\n        offset: -1\r\n      };\r\n    }\r\n  }\r\n\r\n  // fill\r\n  if (model.has(COLOR)) {\r\n    p.fill = {\r\n      scale: COLOR,\r\n      field: model.field(COLOR)\r\n    };\r\n  } else {\r\n    p.fill = {value: model.fieldDef(COLOR).value};\r\n  }\r\n\r\n  // opacity\r\n  var opacity = model.config('marks').opacity;\r\n  if (opacity) p.opacity = {value: opacity};\r\n\r\n  return p;\r\n}\r\n\r\nexport function point(model: Model) {\r\n  // TODO Use Vega's marks properties interface\r\n  var p:any = {};\r\n  const marksConfig = model.config('marks');\r\n\r\n  // x\r\n  if (model.has(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(X)) {\r\n    p.x = {value: model.fieldDef(X).scale.bandWidth / 2};\r\n  }\r\n\r\n  // y\r\n  if (model.has(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(Y)) {\r\n    p.y = {value: model.fieldDef(Y).scale.bandWidth / 2};\r\n  }\r\n\r\n  // size\r\n  if (model.has(SIZE)) {\r\n    p.size = {\r\n      scale: SIZE,\r\n      field: model.field(SIZE)\r\n    };\r\n  } else if (!model.has(SIZE)) {\r\n    p.size = {value: model.fieldDef(SIZE).value};\r\n  }\r\n\r\n  // shape\r\n  if (model.has(SHAPE)) {\r\n    p.shape = {\r\n      scale: SHAPE,\r\n      field: model.field(SHAPE)\r\n    };\r\n  } else if (!model.has(SHAPE)) {\r\n    p.shape = {value: model.fieldDef(SHAPE).value};\r\n  }\r\n\r\n  // fill or stroke\r\n  if (marksConfig.filled) {\r\n    if (model.has(COLOR)) {\r\n      p.fill = {\r\n        scale: COLOR,\r\n        field: model.field(COLOR)\r\n      };\r\n    } else if (!model.has(COLOR)) {\r\n      p.fill = {value: model.fieldDef(COLOR).value};\r\n    }\r\n  } else {\r\n    if (model.has(COLOR)) {\r\n      p.stroke = {\r\n        scale: COLOR,\r\n        field: model.field(COLOR)\r\n      };\r\n    } else if (!model.has(COLOR)) {\r\n      p.stroke = {value: model.fieldDef(COLOR).value};\r\n    }\r\n    p.strokeWidth = {value: model.config('marks').strokeWidth};\r\n  }\r\n\r\n  // opacity\r\n  var opacity = marksConfig.opacity;\r\n  if (opacity) {\r\n    p.opacity = {value: opacity};\r\n  }\r\n\r\n  return p;\r\n}\r\n\r\nexport function line(model: Model) {\r\n  // TODO Use Vega's marks properties interface\r\n  var p:any = {};\r\n\r\n  // x\r\n  if (model.has(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(X)) {\r\n    p.x = {value: 0};\r\n  }\r\n\r\n  // y\r\n  if (model.has(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(Y)) {\r\n    p.y = {field: {group: 'height'}};\r\n  }\r\n\r\n  // stroke\r\n  if (model.has(COLOR)) {\r\n    p.stroke = {\r\n      scale: COLOR,\r\n      field: model.field(COLOR)\r\n    };\r\n  } else if (!model.has(COLOR)) {\r\n    p.stroke = {value: model.fieldDef(COLOR).value};\r\n  }\r\n\r\n  var opacity = model.config('marks').opacity;\r\n  if (opacity) p.opacity = {value: opacity};\r\n\r\n  p.strokeWidth = {value: model.config('marks').strokeWidth};\r\n\r\n  return p;\r\n}\r\n\r\n// TODO(#694): optimize area's usage with bin\r\nexport function area(model: Model) {\r\n  const stack = model.stack();\r\n\r\n  // TODO Use Vega's marks properties interface\r\n  var p:any = {};\r\n\r\n  // x\r\n  if (stack && X === stack.fieldChannel) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X) + '_start'\r\n    };\r\n    p.x2 = {\r\n      scale: X,\r\n      field: model.field(X) + '_end'\r\n    };\r\n  } else if (model.isMeasure(X)) {\r\n    p.x = {scale: X, field: model.field(X)};\r\n    if (model.isDimension(Y)) {\r\n      p.x2 = {\r\n        scale: X,\r\n        value: 0\r\n      };\r\n      p.orient = {value: 'horizontal'};\r\n    }\r\n  } else if (model.has(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_mid'})\r\n    };\r\n  } else {\r\n    p.x = {value: 0};\r\n  }\r\n\r\n  // y\r\n  if (stack && Y === stack.fieldChannel) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y) + '_start'\r\n    };\r\n    p.y2 = {\r\n      scale: Y,\r\n      field: model.field(Y) + '_end'\r\n    };\r\n  } else if (model.isMeasure(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y)\r\n    };\r\n    p.y2 = {\r\n      scale: Y,\r\n      value: 0\r\n    };\r\n  } else if (model.has(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_mid'})\r\n    };\r\n  } else {\r\n    p.y = {field: {group: 'height'}};\r\n  }\r\n\r\n  // fill\r\n  if (model.has(COLOR)) {\r\n    p.fill = {\r\n      scale: COLOR,\r\n      field: model.field(COLOR)\r\n    };\r\n  } else if (!model.has(COLOR)) {\r\n    p.fill = {value: model.fieldDef(COLOR).value};\r\n  }\r\n\r\n  var opacity = model.config('marks').opacity;\r\n  if (opacity) {\r\n    p.opacity = {value: opacity};\r\n  }\r\n\r\n  return p;\r\n}\r\n\r\nexport function tick(model: Model) {\r\n  // TODO Use Vega's marks properties interface\r\n  // FIXME are /3 , /1.5 divisions here correct?\r\n  var p:any = {};\r\n\r\n  // x\r\n  if (model.has(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_mid'})\r\n    };\r\n    if (model.isDimension(X)) {\r\n      p.x.offset = -model.fieldDef(X).scale.bandWidth / 3;\r\n    }\r\n  } else if (!model.has(X)) {\r\n    p.x = {value: 0};\r\n  }\r\n\r\n  // y\r\n  if (model.has(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_mid'})\r\n    };\r\n    if (model.isDimension(Y)) {\r\n      p.y.offset = -model.fieldDef(Y).scale.bandWidth / 3;\r\n    }\r\n  } else if (!model.has(Y)) {\r\n    p.y = {value: 0};\r\n  }\r\n\r\n  // width\r\n  if (!model.has(X) || model.isDimension(X)) {\r\n    // TODO(#694): optimize tick's width for bin\r\n    p.width = {value: model.fieldDef(X).scale.bandWidth / 1.5};\r\n  } else {\r\n    p.width = {value: 1};\r\n  }\r\n\r\n  // height\r\n  if (!model.has(Y) || model.isDimension(Y)) {\r\n    // TODO(#694): optimize tick's height for bin\r\n    p.height = {value: model.fieldDef(Y).scale.bandWidth / 1.5};\r\n  } else {\r\n    p.height = {value: 1};\r\n  }\r\n\r\n  // fill\r\n  if (model.has(COLOR)) {\r\n    p.fill = {\r\n      scale: COLOR,\r\n      field: model.field(COLOR)\r\n    };\r\n  } else {\r\n    p.fill = {value: model.fieldDef(COLOR).value};\r\n  }\r\n\r\n  var opacity = model.config('marks').opacity;\r\n  if (opacity) {\r\n    p.opacity = {value: opacity};\r\n  }\r\n\r\n  return p;\r\n}\r\n\r\nfunction filled_point_props(shape) {\r\n  return function(model: Model) {\r\n    // TODO Use Vega's marks properties interface\r\n    var p:any = {};\r\n\r\n    // x\r\n    if (model.has(X)) {\r\n      p.x = {\r\n        scale: X,\r\n        field: model.field(X, {binSuffix: '_mid'})\r\n      };\r\n    } else if (!model.has(X)) {\r\n      p.x = {value: model.fieldDef(X).scale.bandWidth / 2};\r\n    }\r\n\r\n    // y\r\n    if (model.has(Y)) {\r\n      p.y = {\r\n        scale: Y,\r\n        field: model.field(Y, {binSuffix: '_mid'})\r\n      };\r\n    } else if (!model.has(Y)) {\r\n      p.y = {value: model.fieldDef(Y).scale.bandWidth / 2};\r\n    }\r\n\r\n    // size\r\n    if (model.has(SIZE)) {\r\n      p.size = {\r\n        scale: SIZE,\r\n        field: model.field(SIZE)\r\n      };\r\n    } else if (!model.has(X)) {\r\n      p.size = {value: model.fieldDef(SIZE).value};\r\n    }\r\n\r\n    // shape\r\n    p.shape = {value: shape};\r\n\r\n    // fill\r\n    if (model.has(COLOR)) {\r\n      p.fill = {\r\n        scale: COLOR,\r\n        field: model.field(COLOR)\r\n      };\r\n    } else if (!model.has(COLOR)) {\r\n      p.fill = {value: model.fieldDef(COLOR).value};\r\n    }\r\n\r\n    var opacity = model.config('marks').opacity;\r\n    if (opacity) {\r\n      p.opacity = {value: opacity};\r\n    }\r\n\r\n    return p;\r\n  };\r\n}\r\n\r\nexport const circle = filled_point_props('circle');\r\nexport const square = filled_point_props('square');\r\n\r\nexport function textBackground(model: Model) {\r\n  return {\r\n    x: {value: 0},\r\n    y: {value: 0},\r\n    width: {field: {group: 'width'}},\r\n    height: {field: {group: 'height'}},\r\n    fill: {scale: COLOR, field: model.field(COLOR)}\r\n  };\r\n}\r\n\r\nexport function text(model: Model) {\r\n  // TODO Use Vega's marks properties interface\r\n  let p:any = {};\r\n  const fieldDef = model.fieldDef(TEXT);\r\n  const marksConfig = model.config('marks');\r\n\r\n  // x\r\n  if (model.has(X)) {\r\n    p.x = {\r\n      scale: X,\r\n      field: model.field(X, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(X)) {\r\n    if (model.has(TEXT) && model.fieldDef(TEXT).type === QUANTITATIVE) {\r\n      // TODO: make this -5 offset a config\r\n      p.x = {field: {group: 'width'}, offset: -5};\r\n    } else {\r\n      p.x = {value: model.fieldDef(X).scale.bandWidth / 2};\r\n    }\r\n  }\r\n\r\n  // y\r\n  if (model.has(Y)) {\r\n    p.y = {\r\n      scale: Y,\r\n      field: model.field(Y, {binSuffix: '_mid'})\r\n    };\r\n  } else if (!model.has(Y)) {\r\n    p.y = {value: model.fieldDef(Y).scale.bandWidth / 2};\r\n  }\r\n\r\n  // size\r\n  if (model.has(SIZE)) {\r\n    p.fontSize = {\r\n      scale: SIZE,\r\n      field: model.field(SIZE)\r\n    };\r\n  } else if (!model.has(SIZE)) {\r\n    p.fontSize = {value: fieldDef.fontSize};\r\n  }\r\n\r\n  // fill\r\n  // TODO: consider if color should just map to fill instead?\r\n\r\n\r\n  var opacity = model.config('marks').opacity;\r\n\r\n  // default opacity in vega is 1 if we don't set it\r\n  if (opacity) {\r\n    p.opacity = {value: opacity};\r\n  }\r\n\r\n  // text\r\n  if (model.has(TEXT)) {\r\n    if (model.fieldDef(TEXT).type === QUANTITATIVE) {\r\n      // TODO: revise this line\r\n      var numberFormat = marksConfig.format !== undefined ?\r\n                         marksConfig.format : model.numberFormat(TEXT);\r\n\r\n      p.text = {template: '{{' + model.field(TEXT, {datum: true}) +\r\n               ' | number:\\'' + numberFormat +'\\'}}'};\r\n    } else {\r\n      p.text = {field: model.field(TEXT)};\r\n    }\r\n  } else {\r\n    p.text = {value: fieldDef.value};\r\n  }\r\n\r\n\r\n  ['align', 'baseline', 'fill', 'font', 'fontWeight', 'fontStyle']\r\n    .forEach(function(property) {\r\n      const value = marksConfig[property];\r\n      if (value !== undefined) {\r\n        p[property] = {value: value};\r\n      }\r\n\r\n    });\r\n\r\n  return p;\r\n}\r\n}\r\n","// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\r\ndeclare var exports;\r\n\r\nimport {extend} from '../util';\r\nimport {Model} from './Model';\r\nimport {SHARED_DOMAIN_OPS} from '../aggregate';\r\nimport {COLUMN, ROW, X, Y, SHAPE, SIZE, COLOR, TEXT, Channel} from '../channel';\r\nimport {SOURCE, STACKED, LAYOUT} from '../data';\r\nimport * as time from './time';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\r\n\r\nexport function compileScales(names: Array<string>, model: Model) {\r\n  return names.reduce(function(a, channel: Channel) {\r\n    var scaleDef: any = {\r\n      name: channel,\r\n      type: type(channel, model),\r\n    };\r\n\r\n    scaleDef.domain = domain(model, channel, scaleDef.type);\r\n    extend(scaleDef, rangeMixins(model, channel, scaleDef.type));\r\n\r\n    // Add optional properties\r\n    [\r\n      // general properties\r\n      'reverse', 'round',\r\n      // quantitative / time\r\n      'clamp', 'nice',\r\n      // quantitative\r\n      'exponent', 'zero',\r\n      // ordinal\r\n      'bandWidth', 'outerPadding', 'padding', 'points'\r\n    ].forEach(function(property) {\r\n      // TODO include fieldDef as part of the parameters\r\n      var value = exports[property](model, channel, scaleDef.type);\r\n      if (value !== undefined) {\r\n        scaleDef[property] = value;\r\n      }\r\n    });\r\n\r\n    return (a.push(scaleDef), a);\r\n  }, []);\r\n}\r\n\r\nexport function type(channel: Channel, model: Model) {\r\n  const fieldDef = model.fieldDef(channel);\r\n  switch (fieldDef.type) {\r\n    case NOMINAL: //fall through\r\n      return 'ordinal';\r\n    case ORDINAL:\r\n      let range = fieldDef.scale.range;\r\n      return channel === COLOR && (typeof range !== 'string') ? 'linear' : 'ordinal';\r\n    case TEMPORAL:\r\n      return fieldDef.timeUnit ? time.scale.type(fieldDef.timeUnit, channel) : 'time';\r\n    case QUANTITATIVE:\r\n      if (model.bin(channel)) {\r\n        return channel === ROW || channel === COLUMN || channel === SHAPE ? 'ordinal' : 'linear';\r\n      }\r\n      return fieldDef.scale.type;\r\n  }\r\n}\r\n\r\nexport function domain(model: Model, channel:Channel, type) {\r\n  var fieldDef = model.fieldDef(channel);\r\n\r\n  if (fieldDef.scale.domain) { // explicit value\r\n    return fieldDef.scale.domain;\r\n  }\r\n\r\n  // special case for temporal scale\r\n  if (fieldDef.type === TEMPORAL) {\r\n    var range = time.scale.domain(fieldDef.timeUnit, channel);\r\n    if (range) return range;\r\n  }\r\n\r\n  // For stack, use STACKED data.\r\n  var stack = model.stack();\r\n  if (stack && channel === stack.fieldChannel) {\r\n    const facet = model.has(ROW) || model.has(COLUMN);\r\n    return {\r\n      data: STACKED,\r\n      field: model.field(channel, {\r\n        // If faceted, scale is determined by the max of sum in each facet.\r\n        prefn: (facet ? 'max_' : '') + 'sum_'\r\n      })\r\n    };\r\n  }\r\n\r\n  var useRawDomain = _useRawDomain(model, channel);\r\n  var sort = domainSort(model, channel, type);\r\n\r\n  if (useRawDomain) { // useRawDomain - only Q/T\r\n    return {\r\n      data: SOURCE,\r\n      field: model.field(channel, {noAggregate:true})\r\n    };\r\n  } else if (fieldDef.bin) { // bin\r\n\r\n    return {\r\n      data: model.dataTable(),\r\n      field: type === 'ordinal' ?\r\n        // ordinal scale only use bin start for now\r\n        model.field(channel, { binSuffix: '_start' }) :\r\n        // need to merge both bin_start and bin_end for non-ordinal scale\r\n        [\r\n          model.field(channel, { binSuffix: '_start' }),\r\n          model.field(channel, { binSuffix: '_end' })\r\n        ]\r\n    };\r\n  } else if (sort) { // have sort -- only for ordinal\r\n    return {\r\n      // If sort by aggregation of a specified sort field, we need to use SOURCE table,\r\n      // so we can aggregate values for the scale independently from the main aggregation.\r\n      data: sort.op ? SOURCE : model.dataTable(),\r\n      field: model.field(channel),\r\n      sort: sort\r\n    };\r\n  } else {\r\n    return {\r\n      data: model.dataTable(),\r\n      field: model.field(channel)\r\n    };\r\n  }\r\n}\r\n\r\nexport function domainSort(model: Model, channel: Channel, type):any {\r\n  var sort = model.fieldDef(channel).sort;\r\n  if (sort === 'ascending' || sort === 'descending') {\r\n    return true;\r\n  }\r\n\r\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\r\n  if (type === 'ordinal' && typeof sort !== 'string') {\r\n    return {\r\n      op: sort.op,\r\n      field: sort.field\r\n    };\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function reverse(model: Model, channel: Channel) {\r\n  var sort = model.fieldDef(channel).sort;\r\n  return sort && (typeof sort === 'string' ?\r\n                    sort === 'descending' :\r\n                    sort.order === 'descending'\r\n                 ) ? true : undefined;\r\n}\r\n\r\n/**\r\n * Determine if useRawDomain should be activated for this scale.\r\n * @return {Boolean} Returns true if all of the following conditons applies:\r\n * 1. `useRawDomain` is enabled either through scale or config\r\n * 2. Aggregation function is not `count` or `sum`\r\n * 3. The scale is quantitative or time scale.\r\n */\r\nexport function _useRawDomain (model: Model, channel: Channel) {\r\n  const fieldDef = model.fieldDef(channel);\r\n\r\n  return fieldDef.scale.useRawDomain && //  if useRawDomain is enabled\r\n    // only applied to aggregate table\r\n    fieldDef.aggregate &&\r\n    // only activated if used with aggregate functions that produces values ranging in the domain of the source data\r\n    SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&\r\n    (\r\n      // Q always uses quantitative scale except when it's binned.\r\n      // Binned field has similar values in both the source table and the summary table\r\n      // but the summary table has fewer values, therefore binned fields draw\r\n      // domain values from the summary table.\r\n      (fieldDef.type === QUANTITATIVE && !fieldDef.bin) ||\r\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\r\n      (fieldDef.type === TEMPORAL &&\r\n        (!fieldDef.timeUnit || time.scale.type(fieldDef.timeUnit, channel) === 'linear')\r\n      )\r\n    );\r\n}\r\n\r\nexport function bandWidth(model: Model, channel: Channel, scaleType) {\r\n  if (scaleType === 'ordinal') {\r\n    return model.fieldDef(channel).scale.bandWidth;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function clamp(model: Model, channel: Channel) {\r\n  // only return value if explicit value is specified.\r\n  return model.fieldDef(channel).scale.clamp;\r\n}\r\n\r\nexport function exponent(model: Model, channel: Channel) {\r\n  // only return value if explicit value is specified.\r\n  return model.fieldDef(channel).scale.exponent;\r\n}\r\n\r\nexport function nice(model: Model, channel: Channel, scaleType) {\r\n  if (model.fieldDef(channel).scale.nice !== undefined) {\r\n    // explicit value\r\n    return model.fieldDef(channel).scale.nice;\r\n  }\r\n\r\n  switch (channel) {\r\n    case X: /* fall through */\r\n    case Y:\r\n      if (scaleType === 'time' || scaleType === 'ordinal') {\r\n        return undefined;\r\n      }\r\n      return true;\r\n\r\n    case ROW: /* fall through */\r\n    case COLUMN:\r\n      return true;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function outerPadding(model: Model, channel: Channel, scaleType) {\r\n  if (scaleType === 'ordinal') {\r\n    if (model.fieldDef(channel).scale.outerPadding !== undefined) {\r\n      return model.fieldDef(channel).scale.outerPadding; // explicit value\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function padding(model: Model, channel: Channel, scaleType) {\r\n  if (scaleType === 'ordinal') {\r\n    // Both explicit and non-explicit values are handled by the helper method.\r\n    return model.fieldDef(channel).scale.padding;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function points(model: Model, channel: Channel, scaleType) {\r\n  if (scaleType === 'ordinal') {\r\n    if (model.fieldDef(channel).scale.points !== undefined) {\r\n      // explicit value\r\n      return model.fieldDef(channel).scale.points;\r\n    }\r\n\r\n    switch (channel) {\r\n      case X:\r\n      case Y:\r\n        return true;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\nexport function rangeMixins(model: Model, channel: Channel, scaleType): any {\r\n  var fieldDef = model.fieldDef(channel);\r\n\r\n  if (fieldDef.scale.range) { // explicit value\r\n    return {range: fieldDef.scale.range};\r\n  }\r\n\r\n  switch (channel) {\r\n    case X:\r\n      return { rangeMin: 0, rangeMax: model.layout().cellWidth};\r\n    case Y:\r\n      if (scaleType === 'ordinal') {\r\n        return {rangeMin: 0, rangeMax: model.layout().cellHeight};\r\n      }\r\n      return {rangeMin: model.layout().cellHeight, rangeMax :0};\r\n    case SIZE:\r\n      if (model.is('bar')) {\r\n        // FIXME this is definitely incorrect\r\n        // but let's fix it later since bar size is a bad encoding anyway\r\n        return {\r\n          range: [3, Math.max(\r\n            model.fieldDef(X).scale.bandWidth,\r\n            model.fieldDef(Y).scale.bandWidth\r\n          )]\r\n        };\r\n      } else if (model.is(TEXT)) {\r\n        return {range: [8, 40]};\r\n      }\r\n      // else -- point\r\n      var bandWidth = Math.min(model.fieldDef(X).scale.bandWidth, model.fieldDef(Y).scale.bandWidth) - 1;\r\n      return {range: [10, 0.8 * bandWidth*bandWidth]};\r\n    case SHAPE:\r\n      return {range: 'shapes'};\r\n    case COLOR:\r\n      if (scaleType === 'ordinal') {\r\n        return {range: 'category10'};\r\n      } else { //time or quantitative\r\n        return {range: ['#AFC6A3', '#09622A']}; // tableau greens\r\n      }\r\n    case ROW:\r\n      return {range: 'height'};\r\n    case COLUMN:\r\n      return {range: 'width'};\r\n  }\r\n  return {};\r\n}\r\n\r\nexport function round(model: Model, channel: Channel) {\r\n  if (model.fieldDef(channel).scale.round !== undefined) {\r\n    return model.fieldDef(channel).scale.round;\r\n  }\r\n\r\n  // FIXME: revise if round is already the default value\r\n  switch (channel) {\r\n    case X: /* fall through */\r\n    case Y:\r\n    case ROW:\r\n    case COLUMN:\r\n    case SIZE:\r\n      return true;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function zero(model: Model, channel: Channel) {\r\n  var fieldDef = model.fieldDef(channel);\r\n  var timeUnit = fieldDef.timeUnit;\r\n\r\n  if (fieldDef.scale.zero !== undefined) {\r\n    // explicit value\r\n    return fieldDef.scale.zero;\r\n  }\r\n\r\n  if (fieldDef.type === TEMPORAL) {\r\n    if (timeUnit === 'year') {\r\n      // year is using linear scale, but should not include zero\r\n      return false;\r\n    }\r\n    // If there is no timeUnit or the timeUnit uses ordinal scale,\r\n    // zero property is ignored by vega so we should not generate them any way\r\n    return undefined;\r\n  }\r\n  if (fieldDef.bin) {\r\n    // Returns false (undefined) by default of bin\r\n    return false;\r\n  }\r\n\r\n  return channel === X || channel === Y ?\r\n    // if not bin / temporal, returns undefined for X and Y encoding\r\n    // since zero is true by default in vega for linear scale\r\n    undefined :\r\n    false;\r\n}\r\n","import {Model} from './Model';\r\nimport {Channel} from '../channel';\r\nimport {isObject} from '../util';\r\n\r\nexport interface StackProperties {\r\n  groupbyChannel: Channel;\r\n  fieldChannel: Channel;\r\n  stackChannel: Channel; // COLOR or DETAIL\r\n  config: any;\r\n}\r\n\r\n// TODO: put all vega interface in one place\r\ninterface StackTransform {\r\n  type: string;\r\n  offset?: any;\r\n  groupby: any;\r\n  field: any;\r\n  sortby: any;\r\n  output: any;\r\n}\r\n\r\n// impute data for stacked area\r\nexport function imputeTransform(model: Model) {\r\n  const stack = model.stack();\r\n  return {\r\n    type: 'impute',\r\n    field: model.field(stack.fieldChannel),\r\n    groupby: [model.field(stack.stackChannel)],\r\n    orderby: [model.field(stack.groupbyChannel)],\r\n    method: 'value',\r\n    value: 0\r\n  };\r\n}\r\n\r\nexport function stackTransform(model: Model) {\r\n  const stack = model.stack();\r\n  const sortby = stack.config.sort === 'descending' ?\r\n                   '-' + model.field(stack.stackChannel) :\r\n                 stack.config.sort === 'ascending' ?\r\n                   model.field(stack.stackChannel) :\r\n                 isObject(stack.config.sort) ?\r\n                   stack.config.sort :\r\n                   '-' + model.field(stack.stackChannel); // default\r\n\r\n  const valName = model.field(stack.fieldChannel);\r\n\r\n  // add stack transform to mark\r\n  var transform: StackTransform = {\r\n    type: 'stack',\r\n    groupby: [model.field(stack.groupbyChannel)],\r\n    field: model.field(stack.fieldChannel),\r\n    sortby: sortby,\r\n    output: {\r\n      start: valName + '_start',\r\n      end: valName + '_end'\r\n    }\r\n  };\r\n\r\n  if (stack.config.offset) {\r\n    transform.offset = stack.config.offset;\r\n  }\r\n  return transform;\r\n}\r\n","import {Model} from './Model';\r\nimport {FieldDef} from '../schema/fielddef.schema';\r\nimport * as vlFieldDef from '../fielddef';\r\nimport * as util from '../util';\r\nimport {COLOR, COLUMN, ROW, Channel} from '../channel';\r\nimport {TEMPORAL} from '../type';\r\n\r\nexport function cardinality(fieldDef: FieldDef, stats, filterNull, type) {\r\n  var timeUnit = fieldDef.timeUnit;\r\n  switch (timeUnit) {\r\n    case 'seconds': return 60;\r\n    case 'minutes': return 60;\r\n    case 'hours': return 24;\r\n    case 'day': return 7;\r\n    case 'date': return 31;\r\n    case 'month': return 12;\r\n    case 'year':\r\n      var stat = stats[fieldDef.field],\r\n        yearstat = stats['year_' + fieldDef.field];\r\n\r\n      if (!yearstat) { return null; }\r\n\r\n      return yearstat.distinct -\r\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function formula(timeUnit, field: string) {\r\n  // TODO(kanitw): add formula to other time format\r\n  var fn = 'utc' + timeUnit;\r\n  return fn + '(' + field + ')';\r\n}\r\n\r\nexport function range(timeUnit, model: Model) {\r\n  var labelLength = model.config('timeScaleLabelLength'),\r\n    scaleLabel;\r\n  switch (timeUnit) {\r\n    case 'day':\r\n      scaleLabel = model.config('dayScaleLabel');\r\n      break;\r\n    case 'month':\r\n      scaleLabel = model.config('monthScaleLabel');\r\n      break;\r\n  }\r\n  if (scaleLabel) {\r\n    return labelLength ? scaleLabel.map(\r\n        function(s) { return s.substr(0, labelLength);}\r\n      ) : scaleLabel;\r\n  }\r\n  return;\r\n}\r\n\r\nfunction isOrdinalFn(timeUnit) {\r\n  switch (timeUnit) {\r\n    case 'seconds':\r\n    case 'minutes':\r\n    case 'hours':\r\n    case 'day':\r\n    case 'date':\r\n    case 'month':\r\n      return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport namespace scale {\r\n  export function type(timeUnit, channel: Channel) {\r\n    if (channel === COLOR) {\r\n      return 'linear'; // time has order, so use interpolated ordinal color scale.\r\n    }\r\n\r\n    // FIXME revise this -- should 'year' be linear too?\r\n    return isOrdinalFn(timeUnit) || channel === COLUMN || channel === ROW ? 'ordinal' : 'linear';\r\n  }\r\n\r\n  export function domain(timeUnit, channel?: Channel) {\r\n    var isColor = channel === COLOR;\r\n    switch (timeUnit) {\r\n      case 'seconds':\r\n      case 'minutes': return isColor ? [0,59] : util.range(0, 60);\r\n      case 'hours': return isColor ? [0,23] : util.range(0, 24);\r\n      case 'day': return isColor ? [0,6] : util.range(0, 7);\r\n      case 'date': return isColor ? [1,31] : util.range(1, 32);\r\n      case 'month': return isColor ? [0,11] : util.range(0, 12);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/** returns the template name used for axis labels for a time unit */\r\nexport function labelTemplate(timeUnit, abbreviated=false) : string {\r\n  var postfix = abbreviated ? '-abbrev' : '';\r\n  switch (timeUnit) {\r\n    case 'day':\r\n      return 'day' + postfix;\r\n    case 'month':\r\n      return 'month' + postfix;\r\n  }\r\n  return null;\r\n}\r\n","/*\r\n * Constants and utilities for data.\r\n */\r\n\r\nimport * as util from './util';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from './type';\r\n\r\nexport const SUMMARY = 'summary';\r\nexport const SOURCE = 'source';\r\nexport const STACKED = 'stacked';\r\nexport const LAYOUT = 'layout';\r\n\r\n/** Mapping from datalib's inferred type to Vega-lite's type */\r\n// TODO: ALL_CAPS\r\nexport const types = {\r\n  'boolean': NOMINAL,\r\n  'number': QUANTITATIVE,\r\n  'integer': QUANTITATIVE,\r\n  'date': TEMPORAL,\r\n  'string': NOMINAL\r\n};\r\n","// utility for encoding mapping\r\nimport {Encoding} from './schema/encoding.schema';\r\nimport {FieldDef} from './schema/fielddef.schema';\r\nimport {Channel, CHANNELS} from './channel';\r\n\r\nexport function countRetinal(encoding: Encoding) {\r\n  var count = 0;\r\n  if (encoding.color) count++;\r\n  if (encoding.size) count++;\r\n  if (encoding.shape) count++;\r\n  return count;\r\n}\r\n\r\nexport function has(encoding: Encoding, channel: Channel) {\r\n  var fieldDef: FieldDef = encoding && encoding[channel];\r\n  return fieldDef && fieldDef.field;\r\n}\r\n\r\nexport function isAggregate(encoding: Encoding) {\r\n  for (var k in encoding) {\r\n    if (has(encoding, k) && encoding[k].aggregate) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function forEach(encoding: Encoding,\r\n                        f: (fd: FieldDef, c: Channel, i:number) => void) {\r\n  var i = 0;\r\n  CHANNELS.forEach(function(channel) {\r\n    if (has(encoding, channel)) {\r\n      f(encoding[channel], channel, i++);\r\n    }\r\n  });\r\n}\r\n\r\nexport function map(encoding: Encoding,\r\n                    f: (fd: FieldDef, c: Channel, e: Encoding) => any) {\r\n  var arr = [];\r\n  CHANNELS.forEach(function(k) {\r\n    if (has(encoding, k)) {\r\n      arr.push(f(encoding[k], k, encoding));\r\n    }\r\n  });\r\n  return arr;\r\n}\r\n\r\nexport function reduce(encoding: Encoding,\r\n                  f: (acc: any, fd: FieldDef, c: Channel, e: Encoding) => any,\r\n                  init) {\r\n  var r = init;\r\n  CHANNELS.forEach(function(k) {\r\n    if (has(encoding, k)) {\r\n      r = f(r, encoding[k], k,  encoding);\r\n    }\r\n  });\r\n  return r;\r\n}\r\n","// utility for a field definition object\r\n\r\nimport {FieldDef} from './schema/fielddef.schema';\r\nimport {Bin} from './schema/bin.schema';\r\n\r\nimport {MAXBINS_DEFAULT} from './bin';\r\nimport {AGGREGATE_OPS} from './aggregate';\r\nimport {contains, getbins} from './util';\r\nimport * as time from './compiler/time';\r\nimport {TIMEUNITS} from './timeunit';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL, SHORT_TYPE, TYPE_FROM_SHORT_TYPE} from './type';\r\n\r\n\r\n// TODO remove these \"isDimension/isMeasure\" stuff\r\nfunction _isFieldDimension(fieldDef: FieldDef) {\r\n  return  contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin ||\r\n    (fieldDef.type === TEMPORAL && !!fieldDef.timeUnit );\r\n}\r\n\r\nexport function isDimension(fieldDef: FieldDef) {\r\n  return fieldDef && _isFieldDimension(fieldDef);\r\n}\r\n\r\nexport function isMeasure(fieldDef: FieldDef) {\r\n  return fieldDef && !_isFieldDimension(fieldDef);\r\n}\r\n\r\nexport function count(): FieldDef {\r\n  return {field:'*', aggregate: 'count', type: QUANTITATIVE, displayName: COUNT_DISPLAYNAME};\r\n}\r\n\r\nexport const COUNT_DISPLAYNAME = 'Number of Records';\r\n\r\nexport function isCount(fieldDef: FieldDef) {\r\n  return fieldDef.aggregate === 'count';\r\n}\r\n\r\n// FIXME remove this, and the getbins method\r\nexport function cardinality(fieldDef: FieldDef, stats, filterNull = {}) {\r\n  // FIXME need to take filter into account\r\n\r\n  var stat = stats[fieldDef.field];\r\n  var type = fieldDef.type;\r\n\r\n  if (fieldDef.bin) {\r\n    // need to reassign bin, otherwise compilation will fail due to a TS bug.\r\n    const bin = fieldDef.bin;\r\n    const maxbins = (typeof bin === 'boolean') ? MAXBINS_DEFAULT : bin.maxbins;\r\n\r\n\r\n    var bins = getbins(stat, maxbins);\r\n    return (bins.stop - bins.start) / bins.step;\r\n  }\r\n  if (fieldDef.type === TEMPORAL) {\r\n    var cardinality = time.cardinality(fieldDef, stats, filterNull, type);\r\n    if(cardinality !== null) return cardinality;\r\n    //otherwise use calculation below\r\n  }\r\n  if (fieldDef.aggregate) {\r\n    return 1;\r\n  }\r\n\r\n  // remove null\r\n  return stat.distinct -\r\n    (stat.missing > 0 && filterNull[type] ? 1 : 0);\r\n}\r\n","export const AREA = 'area';\r\nexport const BAR = 'bar';\r\nexport const LINE = 'line';\r\nexport const POINT = 'point';\r\nexport const TEXT = 'text';\r\nexport const TICK = 'tick';\r\n\r\n// TODO: decide if we want to keep them?\r\nexport const CIRCLE = 'circle';\r\nexport const SQUARE = 'square';\r\n","export interface Axis {\r\n  // Vega Axis Properties\r\n  format?: string;\r\n  grid?: boolean;\r\n  layer?: string;\r\n  orient?: string;\r\n  ticks?: number;\r\n  title?: string;\r\n  tickSize?: number;\r\n  offset?: number;\r\n  shortTimeNames?: boolean;\r\n  // Vega-Lite only\r\n  labelMaxLength?: number;\r\n  titleMaxLength?: number;\r\n  titleOffset?: number;\r\n  properties?: any; // TODO: declare VgAxisProperties\r\n}\r\n\r\nexport var axis = {\r\n  type: 'object',\r\n  properties: {\r\n    /* Vega Axis Properties */\r\n    format: {\r\n      type: 'string',\r\n      default: undefined,  // auto\r\n      description: 'The formatting pattern for axis labels. '+\r\n                   'If not undefined, this will be determined by ' +\r\n                   'the max value ' +\r\n                   'of the field.'\r\n    },\r\n    grid: {\r\n      type: 'boolean',\r\n      default: undefined,\r\n      description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\r\n    },\r\n    layer: {\r\n      type: 'string',\r\n      default: undefined,\r\n      description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\r\n    },\r\n    orient: {\r\n      type: 'string',\r\n      default: undefined,\r\n      enum: ['top', 'right', 'left', 'bottom'],\r\n      description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\r\n    },\r\n    ticks: {\r\n      type: 'integer',\r\n      default: undefined,\r\n      minimum: 0,\r\n      description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\r\n    },\r\n    /* Vega Axis Properties that are automatically populated by Vega-lite */\r\n    title: {\r\n      type: 'string',\r\n      default: undefined,\r\n      description: 'A title for the axis. (Shows field name and its function by default.)'\r\n    },\r\n    /* Vega-lite only */\r\n    labelMaxLength: {\r\n      type: 'integer',\r\n      default: 25,\r\n      minimum: 0,\r\n      description: 'Truncate labels that are too long.'\r\n    },\r\n    titleMaxLength: {\r\n      type: 'integer',\r\n      default: undefined,\r\n      minimum: 0,\r\n      description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\r\n    },\r\n    titleOffset: {\r\n      type: 'integer',\r\n      default: undefined,  // auto\r\n      description: 'A title offset value for the axis.'\r\n    },\r\n    shortTimeNames: {\r\n      type: 'boolean',\r\n      default: false,\r\n      description: 'Whether month names and weekday names should be abbreviated.'\r\n    },\r\n    properties: {\r\n      type: 'object',\r\n      default: undefined,\r\n      description: 'Optional mark property definitions for custom axis styling.'\r\n    }\r\n  }\r\n};\r\n","import {MAXBINS_DEFAULT} from '../bin';\r\nimport {QUANTITATIVE} from '../type';\r\nimport {toMap} from '../util';\r\n\r\n// TODO: add other bin properties\r\n\r\nexport interface Bin {\r\n  maxbins: number;\r\n}\r\n\r\nexport var bin = {\r\n  type: ['boolean', 'object'],\r\n  default: false,\r\n  properties: {\r\n    maxbins: {\r\n      type: 'integer',\r\n      default: MAXBINS_DEFAULT,\r\n      minimum: 2,\r\n      description: 'Maximum number of bins.'\r\n    }\r\n  },\r\n  supportedTypes: toMap([QUANTITATIVE]) // TODO: add O after finishing #81\r\n};\r\n","// TODO: add interface Config\r\n\r\nexport var config = {\r\n  type: 'object',\r\n  properties: {\r\n    // template\r\n    width: {\r\n      type: 'integer',\r\n      default: undefined\r\n    },\r\n    height: {\r\n      type: 'integer',\r\n      default: undefined\r\n    },\r\n    viewport: {\r\n      type: 'array',\r\n      items: {\r\n        type: 'integer'\r\n      },\r\n      default: undefined\r\n    },\r\n\r\n    // filter null\r\n    // TODO(#597) revise this config\r\n    filterNull: {\r\n      type: 'object',\r\n      properties: {\r\n        nominal: {type:'boolean', default: false},\r\n        ordinal: {type:'boolean', default: false},\r\n        quantitative: {type:'boolean', default: true},\r\n        temporal: {type:'boolean', default: true}\r\n      }\r\n    },\r\n\r\n    // small multiples\r\n    textCellWidth: {\r\n      type: 'integer',\r\n      default: 90,\r\n      minimum: 0\r\n    },\r\n\r\n    // layout\r\n    // TODO: add orient\r\n    sortLineBy: {\r\n      type: 'string',\r\n      default: undefined,\r\n      description: 'Data field to sort line by. ' +\r\n        '\\'-\\' prefix can be added to suggest descending order.'\r\n    },\r\n    stack: {\r\n      type: ['boolean', 'object'],\r\n      default: {},\r\n      description: 'Enable stacking (for bar and area marks only).',\r\n      properties: {\r\n        sort: {\r\n          oneOf: [{\r\n            type: 'string',\r\n            enum: ['ascending', 'descending']\r\n          },{\r\n            type: 'array',\r\n            items: {type: 'string'},\r\n          }],\r\n          description: 'Order of the stack. ' +\r\n            'This can be either a string (either \"descending\" or \"ascending\")' +\r\n            'or a list of fields to determine the order of stack layers.' +\r\n            'By default, stack uses descending order.'\r\n        },\r\n        offset: {\r\n          type: 'string',\r\n          enum: ['zero', 'center', 'normalize']\r\n          // TODO(#620) refer to Vega spec once it doesn't throw error\r\n          // enum: vgStackSchema.properties.offset.oneOf[0].enum\r\n        }\r\n      }\r\n    },\r\n    // cell\r\n    cell: {\r\n      type: 'object',\r\n      properties: {\r\n        width: {\r\n          type: 'integer',\r\n          default: 200\r\n        },\r\n        height: {\r\n          type: 'integer',\r\n          default: 200\r\n        },\r\n        padding: {\r\n          type: 'integer',\r\n          default: 16,\r\n          description: 'default padding between facets.'\r\n        },\r\n        gridColor: {\r\n          type: 'string',\r\n          role: 'color',\r\n          default: '#000000'\r\n        },\r\n        gridOpacity: {\r\n          type: 'number',\r\n          minimum: 0,\r\n          maximum: 1,\r\n          default: 0.25\r\n        },\r\n        gridOffset: {\r\n          type: 'number',\r\n          default: 6 // equal to tickSize\r\n        },\r\n        fill: {\r\n          type: 'string',\r\n          role: 'color',\r\n          default: 'rgba(0,0,0,0)'\r\n        },\r\n        fillOpacity: {\r\n          type: 'number',\r\n        },\r\n        stroke: {\r\n          type: 'string',\r\n          role: 'color',\r\n        },\r\n        strokeWidth: {\r\n          type: 'integer'\r\n        },\r\n        strokeOpacity: {\r\n          type: 'number'\r\n        },\r\n        strokeDash: {\r\n          type: 'array',\r\n          default: undefined\r\n        },\r\n        strokeDashOffset: {\r\n          type: 'integer',\r\n          description: 'The offset (in pixels) into which to begin drawing with the stroke dash array.'\r\n        }\r\n      }\r\n    },\r\n    marks: {\r\n      type: 'object',\r\n      properties: {\r\n        // Vega-Lite special\r\n        filled: {\r\n          type: 'boolean',\r\n          default: false,\r\n          description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\r\n        },\r\n        format: {\r\n          type: 'string',\r\n          default: '',  // auto\r\n          description: 'The formatting pattern for text value.'+\r\n                       'If not defined, this will be determined automatically'\r\n        },\r\n\r\n        // General Vega\r\n        opacity: {\r\n          type: 'number',\r\n          default: undefined,  // auto\r\n          minimum: 0,\r\n          maximum: 1\r\n        },\r\n        strokeWidth: {\r\n          type: 'integer',\r\n          default: 2,\r\n          minimum: 0\r\n        },\r\n\r\n        // text-only\r\n        align: {\r\n          type: 'string',\r\n          default: 'right',\r\n          enum: ['left', 'right', 'center'],\r\n          description: 'The horizontal alignment of the text. One of left, right, center.'\r\n        },\r\n        baseline: {\r\n          type: 'string',\r\n          default: 'middle',\r\n          enum: ['top', 'middle', 'bottom'],\r\n          description: 'The vertical alignment of the text. One of top, middle, bottom.'\r\n        },\r\n        // TODO dx, dy, radius, theta, angle\r\n        fill: {\r\n          type: 'string',\r\n          role: 'color',\r\n          default: '#000000'\r\n        },\r\n        font: {\r\n          type: 'string',\r\n          default: undefined,\r\n          role: 'font',\r\n          description: 'The typeface to set the text in (e.g., Helvetica Neue).'\r\n        },\r\n        fontSize: {\r\n          type: 'integer',\r\n          default: undefined,\r\n          minimum: 0,\r\n          description: 'The font size, in pixels.'\r\n        },\r\n        fontStyle: {\r\n          type: 'string',\r\n          default: undefined,\r\n          enum: ['normal', 'italic'],\r\n          description: 'The font style (e.g., italic).'\r\n        },\r\n        fontWeight: {\r\n          type: 'string',\r\n          enum: ['normal', 'bold'],\r\n          default: undefined,\r\n          description: 'The font weight (e.g., bold).'\r\n        }\r\n      }\r\n    },\r\n\r\n    // FIXME remove this \r\n    singleBarOffset: {\r\n      type: 'integer',\r\n      default: 5,\r\n      minimum: 0\r\n    },\r\n    // other\r\n    characterWidth: {\r\n      type: 'integer',\r\n      default: 6\r\n    },\r\n    // FIXME(#497) handle this\r\n    numberFormat: {\r\n      type: 'string',\r\n      default: 's',\r\n      description: 'D3 Number format for axis labels and text tables.'\r\n    },\r\n    // FIXME(#497) handle this\r\n    timeFormat: {\r\n      type: 'string',\r\n      default: '%Y-%m-%d',\r\n      description: 'Date format for axis labels.'\r\n    }\r\n  }\r\n};\r\n","export interface Data {\r\n  formatType?: string;\r\n  url?: string;\r\n  values?: any[];\r\n  filter?: string;\r\n  calculate?: VgFormula[];\r\n}\r\n\r\n// TODO move this to one central position\r\nexport interface VgFormula {\r\n  field: string;\r\n  expr: string;\r\n}\r\n\r\nexport var data = {\r\n  type: 'object',\r\n  properties: {\r\n    // data source\r\n    formatType: {\r\n      type: 'string',\r\n      enum: ['json', 'csv', 'tsv'],\r\n      default: 'json'\r\n    },\r\n    url: {\r\n      type: 'string',\r\n      default: undefined\r\n    },\r\n    values: {\r\n      type: 'array',\r\n      default: undefined,\r\n      description: 'Pass array of objects instead of a url to a file.',\r\n      items: {\r\n        type: 'object',\r\n        additionalProperties: true\r\n      }\r\n    },\r\n    // we generate a vega filter transform\r\n    filter: {\r\n      type: 'string',\r\n      default: undefined,\r\n      description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\r\n    },\r\n    // we generate a vega formula transform\r\n    calculate: {\r\n      type: 'array',\r\n      default: undefined,\r\n      description: 'Calculate new field(s) using the provided expresssion(s). Calculation are applied before filter.',\r\n      items: {\r\n        type: 'object',\r\n        properties: {\r\n          field: {\r\n            type: 'string',\r\n            description: 'The field in which to store the computed formula value.'\r\n          },\r\n          expr: {\r\n            type: 'string',\r\n            description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","import {merge} from './schemautil';\r\nimport {duplicate} from '../util';\r\nimport * as vlUtil from '../util';\r\n\r\n\r\nimport {axis} from './axis.schema';\r\nimport {FieldDef} from './fielddef.schema';\r\nimport {legend} from './legend.schema';\r\nimport {sort} from './sort.schema';\r\nimport {typicalField, onlyOrdinalField} from './fielddef.schema';\r\n\r\nexport interface Encoding {\r\n  x?: FieldDef;\r\n  y?: FieldDef;\r\n  row?: FieldDef;\r\n  column?: FieldDef;\r\n  color?: FieldDef;\r\n  size?: FieldDef;\r\n  shape?: FieldDef;\r\n  detail?: FieldDef;\r\n  text?: FieldDef;\r\n}\r\n\r\n// TODO: remove if possible\r\nvar requiredNameType = {\r\n  required: ['field', 'type']\r\n};\r\n\r\nvar x = merge(duplicate(typicalField), requiredNameType, {\r\n  properties: {\r\n    scale: {// replacing default values for just these two axes\r\n      properties: {\r\n        padding: {default: 1},\r\n        bandWidth: {default: 21}\r\n      }\r\n    },\r\n    axis: axis,\r\n    sort: sort\r\n  }\r\n});\r\n\r\nvar y = duplicate(x);\r\n\r\nvar facet = merge(duplicate(onlyOrdinalField), requiredNameType, {\r\n  properties: {\r\n    axis: axis,\r\n    sort: sort\r\n  }\r\n});\r\n\r\nvar row = merge(duplicate(facet));\r\nvar column = merge(duplicate(facet));\r\n\r\nvar size = merge(duplicate(typicalField), {\r\n  properties: {\r\n    legend: legend,\r\n    sort: sort,\r\n    value: {\r\n      type: 'integer',\r\n      default: 30,\r\n      minimum: 0,\r\n      description: 'Size of marks.'\r\n    }\r\n  }\r\n});\r\n\r\nvar color = merge(duplicate(typicalField), {\r\n  properties: {\r\n    legend: legend,\r\n    sort: sort,\r\n    value: {\r\n      type: 'string',\r\n      role: 'color',\r\n      default: '#4682b4',\r\n      description: 'Color to be used for marks.'\r\n    },\r\n    scale: {\r\n      type: 'object',\r\n      properties: {\r\n        quantitativeRange: {\r\n          type: 'array',\r\n          default: ['#AFC6A3', '#09622A'], // tableau greens\r\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\r\n          description: 'Color range to encode quantitative variables.',\r\n          minItems: 2,\r\n          maxItems: 2,\r\n          items: {\r\n            type: 'string',\r\n            role: 'color'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nvar shape = merge(duplicate(onlyOrdinalField), {\r\n  properties: {\r\n    legend: legend,\r\n    sort: sort,\r\n    value: {\r\n      type: 'string',\r\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\r\n      default: 'circle',\r\n      description: 'Mark to be used.'\r\n    }\r\n  }\r\n});\r\n\r\nvar detail = merge(duplicate(onlyOrdinalField), {\r\n  properties: {\r\n    sort: sort\r\n  }\r\n});\r\n\r\n// we only put aggregated measure in pivot table\r\nvar text = merge(duplicate(typicalField), {\r\n  properties: {\r\n    sort: sort,\r\n    value: {\r\n      type: 'string',\r\n      default: 'Abc'\r\n    }\r\n  }\r\n});\r\n\r\nexport var encoding = {\r\n  type: 'object',\r\n  properties: {\r\n    x: x,\r\n    y: y,\r\n    row: row,\r\n    column: column,\r\n    size: size,\r\n    color: color,\r\n    shape: shape,\r\n    text: text,\r\n    detail: detail\r\n  }\r\n};\r\n","import {Axis} from './axis.schema';\r\nimport {bin, Bin} from './bin.schema';\r\nimport {Legend} from './legend.schema';\r\nimport {typicalScale, ordinalOnlyScale, Scale} from './scale.schema';\r\nimport {Sort} from './sort.schema';\r\n\r\nimport {AGGREGATE_OPS} from '../aggregate';\r\nimport {toMap, duplicate} from '../util';\r\nimport {merge} from './schemautil';\r\nimport {TIMEUNITS} from '../timeunit';\r\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\r\n\r\nexport interface FieldDef {\r\n  field?: string;\r\n  type?: string;\r\n  value?: any;\r\n\r\n  // function\r\n  aggregate?: string;\r\n  timeUnit?: string;\r\n  bin?: boolean | Bin;\r\n\r\n  sort?: Sort | string;\r\n\r\n  // override vega components\r\n  axis?: Axis;\r\n  legend?: Legend | boolean;\r\n  scale?: Scale;\r\n\r\n  // text\r\n  align?: string;\r\n  baseline?: string;\r\n  color?: string;\r\n  margin?: number;\r\n  placeholder?: string;\r\n  font?: any; // declare font\r\n  format?: string;\r\n  fontSize?: number;\r\n\r\n  // TODO: move to config\r\n  filled?: boolean;\r\n  opacity?: number;\r\n\r\n  // TODO: maybe extend this in other app?\r\n  // unused metadata -- for other application\r\n  displayName?: string;\r\n}\r\n\r\nexport var fieldDef = {\r\n  type: 'object',\r\n  properties: {\r\n    field: {\r\n      type: 'string'\r\n    },\r\n    type: {\r\n      type: 'string',\r\n      enum: [NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL]\r\n    },\r\n    timeUnit: {\r\n      type: 'string',\r\n      enum: TIMEUNITS,\r\n      supportedTypes: toMap([TEMPORAL])\r\n    },\r\n    bin: bin,\r\n  }\r\n};\r\n\r\nexport var aggregate = {\r\n  type: 'string',\r\n  enum: AGGREGATE_OPS,\r\n  supportedEnums: {\r\n    quantitative: AGGREGATE_OPS,\r\n    ordinal: ['median','min','max'],\r\n    nominal: [],\r\n    temporal: ['mean', 'median', 'min', 'max'], // TODO: revise what should time support\r\n    '': ['count']\r\n  },\r\n  supportedTypes: toMap([QUANTITATIVE, NOMINAL, ORDINAL, TEMPORAL, ''])\r\n};\r\n\r\nexport var typicalField = merge(duplicate(fieldDef), {\r\n  properties: {\r\n    aggregate: aggregate,\r\n    scale: typicalScale\r\n  }\r\n});\r\n\r\nexport var onlyOrdinalField = merge(duplicate(fieldDef), {\r\n  properties: {\r\n    aggregate: {\r\n      type: 'string',\r\n      enum: ['count'],\r\n      supportedTypes: toMap([NOMINAL, ORDINAL])\r\n    },\r\n    scale: ordinalOnlyScale\r\n  }\r\n});\r\n","import {isObject} from '../util';\r\n\r\nexport interface Legend {\r\n  orient?: string;\r\n  title?: string;\r\n  format?: string;\r\n  values?: Array<any>;\r\n  properties?: any; //TODO declare VgLegendProperties\r\n}\r\n\r\nexport var legend = {\r\n  default: true,\r\n  description: 'Properties of a legend or boolean flag for determining whether to show it.',\r\n  oneOf: [{\r\n    type: 'object',\r\n    properties: {\r\n      orient: {\r\n        type: 'string',\r\n        default: undefined,\r\n        description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\r\n      },\r\n      title: {\r\n        type: 'string',\r\n        default: undefined,\r\n        description: 'A title for the legend. (Shows field name and its function by default.)'\r\n      },\r\n      format: {\r\n        type: 'string',\r\n        default: undefined,\r\n        description: 'An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.'\r\n      },\r\n      values: {\r\n        type: 'array',\r\n        default: undefined,\r\n        description: 'Explicitly set the visible legend values.'\r\n      },\r\n      properties: {\r\n        type: 'object',\r\n        default: undefined,\r\n        description: 'Optional mark property definitions for custom legend styling. '\r\n      }\r\n    }\r\n  }, {\r\n    type: 'boolean'\r\n  }]\r\n};\r\n","export var marktype = {\r\n  type: 'string',\r\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\r\n};\r\n","import {toMap, duplicate as clone} from '../util';\r\nimport {merge} from './schemautil';\r\nimport {QUANTITATIVE, TEMPORAL} from '../type';\r\n\r\nexport interface Scale {\r\n  type?: string;\r\n  domain?: any; // TODO: declare vgDataDomain\r\n  range?: any; // TODO: declare vgRangeDomain\r\n  round?: boolean;\r\n\r\n  // ordinal\r\n  bandWidth?: number;\r\n  outerPadding?: number;\r\n  padding?: number;\r\n  points?: boolean;\r\n\r\n  // typical\r\n  clamp?: boolean;\r\n  nice?: boolean|string;\r\n  exponent?: number;\r\n  zero?: boolean;\r\n\r\n  // Vega-Lite only\r\n  useRawDomain?: boolean;\r\n}\r\n\r\nvar scale = {\r\n  type: 'object',\r\n  // TODO: refer to Vega's scale schema\r\n  properties: {\r\n    /* Common Scale Properties */\r\n    type: {\r\n      type: 'string',\r\n      // TODO(kanitw) read vega's schema here, add description\r\n      enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\r\n      default: 'linear',\r\n      supportedTypes: toMap([QUANTITATIVE])\r\n    },\r\n    domain: {\r\n      default: undefined,\r\n      type: ['array', 'object'],\r\n      description: 'The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values. The domain may also be specified by a reference to a data source.'\r\n    },\r\n    range: {\r\n      default: undefined,\r\n      type: ['array', 'object', 'string'],\r\n      description: 'The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.'\r\n    },\r\n    round: {\r\n      default: undefined, // TODO: revise default\r\n      type: 'boolean',\r\n      description: 'If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.'\r\n    }\r\n  }\r\n};\r\n\r\n\r\nvar ordinalScaleMixin = {\r\n  properties: {\r\n    bandWidth: {\r\n      type: 'integer',\r\n      minimum: 0,\r\n      default: undefined\r\n    },\r\n    /* Ordinal Scale Properties */\r\n    outerPadding: {\r\n      type: 'number',\r\n      default: undefined\r\n      // TODO: add description once it is documented in Vega\r\n    },\r\n    padding: {\r\n      type: 'number',\r\n      default: undefined,\r\n      description: 'Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).'\r\n        },\r\n    points: {\r\n      type: 'boolean',\r\n      default: undefined,\r\n      description: 'If true, distributes the ordinal values over a quantitative range at uniformly spaced points. The spacing of the points can be adjusted using the padding property. If false, the ordinal scale will construct evenly-spaced bands, rather than points.'\r\n    }\r\n  }\r\n};\r\n\r\nvar typicalScaleMixin = {\r\n  properties: {\r\n    /* Quantitative and temporal Scale Properties */\r\n    clamp: {\r\n      type: 'boolean',\r\n      default: true,\r\n      description: 'If true, values that exceed the data domain are clamped to either the minimum or maximum range value'\r\n    },\r\n    nice: {\r\n      default: undefined,\r\n      oneOf: [\r\n        {\r\n          type: 'boolean',\r\n          description: 'If true, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96).'\r\n        },{\r\n          type: 'string',\r\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\r\n          description: 'If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval; legal values are \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", or \"year\".'\r\n        }\r\n      ],\r\n      // FIXME this part might break polestar\r\n      supportedTypes: toMap([QUANTITATIVE, TEMPORAL]),\r\n      description: ''\r\n    },\r\n\r\n    /* Quantitative Scale Properties */\r\n    exponent: {\r\n      type: 'number',\r\n      default: undefined,\r\n      description: 'Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.'\r\n    },\r\n    zero: {\r\n      type: 'boolean',\r\n      description: 'If true, ensures that a zero baseline value is included in the scale domain. This option is ignored for non-quantitative scales.',\r\n      default: undefined,\r\n      supportedTypes: toMap([QUANTITATIVE, TEMPORAL])\r\n    },\r\n\r\n    /* Vega-lite only Properties */\r\n    useRawDomain: {\r\n      type: 'boolean',\r\n      default: false,\r\n      description: 'Uses the source data range as scale domain instead of ' +\r\n                   'aggregated data for aggregate axis. ' +\r\n                   'This option does not work with sum or count aggregate' +\r\n                   'as they might have a substantially larger scale range.' \r\n    }\r\n  }\r\n};\r\n\r\nexport var ordinalOnlyScale = merge(clone(scale), ordinalScaleMixin);\r\nexport var typicalScale = merge(clone(scale), ordinalScaleMixin, typicalScaleMixin);\r\n","// Package of defining Vega-lite Specification's json schema\r\n\r\n/// <reference path=\"../../typings/vega.d.ts\"/>\r\n\r\nimport * as schemaUtil from './schemautil';\r\nimport {marktype} from './marktype.schema';\r\nimport {config} from './config.schema';\r\nimport {data, Data} from './data.schema';\r\nimport {encoding, Encoding} from './encoding.schema';\r\n\r\nexport interface Spec {\r\n  data?: Data;\r\n  marktype?: string;\r\n  encoding?: Encoding;\r\n  config?: any; // FIXME: declare\r\n}\r\n\r\n// TODO remove this\r\nexport {aggregate} from './fielddef.schema';\r\n\r\nexport var util = schemaUtil;\r\n\r\n/** @type Object Schema of a vega-lite specification */\r\nexport var schema = {\r\n  $schema: 'http://json-schema.org/draft-04/schema#',\r\n  description: 'Schema for Vega-lite specification',\r\n  type: 'object',\r\n  required: ['marktype', 'encoding'],\r\n  properties: {\r\n    data: data,\r\n    marktype: marktype,\r\n    encoding: encoding,\r\n    config: config\r\n  }\r\n};\r\n\r\n/** Instantiate a verbose vl spec from the schema */\r\nexport function instantiate() {\r\n  return schemaUtil.instantiate(schema);\r\n};\r\n","import * as util from '../util';\r\n\r\nfunction isEmpty(obj) {\r\n  return Object.keys(obj).length === 0;\r\n};\r\n\r\nexport function extend(instance, schema) {\r\n  return merge(instantiate(schema), instance);\r\n};\r\n\r\n// instantiate a schema\r\nexport function instantiate(schema) {\r\n  var val;\r\n  if (schema === undefined) {\r\n    return undefined;\r\n  } else if ('default' in schema) {\r\n    val = schema.default;\r\n    return util.isObject(val) ? util.duplicate(val) : val;\r\n  } else if (schema.type === 'object') {\r\n    var instance = {};\r\n    for (var name in schema.properties) {\r\n      val = instantiate(schema.properties[name]);\r\n      if (val !== undefined) {\r\n        instance[name] = val;\r\n      }\r\n    }\r\n    return instance;\r\n  } else if (schema.type === 'array') {\r\n    return undefined;\r\n  }\r\n  return undefined;\r\n};\r\n\r\n// remove all defaults from an instance\r\nexport function subtract(instance, defaults) {\r\n  var changes:any = {};\r\n  for (var prop in instance) {\r\n    var def = defaults[prop];\r\n    var ins = instance[prop];\r\n    // Note: does not properly subtract arrays\r\n    if (!defaults || def !== ins) {\r\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\r\n        var c = subtract(ins, def);\r\n        if (!isEmpty(c)) {\r\n          changes[prop] = c;\r\n        }\r\n      } else if (util.isArray(ins)) {\r\n        if (util.isArray(def)) {\r\n          // check each item in the array\r\n          if (ins.length === def.length) {\r\n            var equal = true;\r\n            for (var i = 0 ; i < ins.length; i++) {\r\n              if (ins[i] !== def[i]) {\r\n                equal = false;\r\n                break;\r\n              }\r\n            }\r\n            if (equal) {\r\n              continue; // continue with next property\r\n            }\r\n          }\r\n        }\r\n        changes[prop] = ins;\r\n      } else {\r\n        changes[prop] = ins;\r\n      }\r\n    }\r\n  }\r\n  return changes;\r\n};\r\n\r\nexport function merge(dest, ...src: any[]){\r\n  for (var i=0 ; i<src.length; i++) {\r\n    dest = merge_(dest, src[i]);\r\n  }\r\n  return dest;\r\n};\r\n\r\n// recursively merges src into dest\r\nfunction merge_(dest, src) {\r\n  if (typeof src !== 'object' || src === null) {\r\n    return dest;\r\n  }\r\n\r\n  for (var p in src) {\r\n    if (!src.hasOwnProperty(p)) {\r\n      continue;\r\n    }\r\n    if (src[p] === undefined) {\r\n      continue;\r\n    }\r\n    if (typeof src[p] !== 'object' || src[p] === null) {\r\n      dest[p] = src[p];\r\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\r\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\r\n    } else {\r\n      merge(dest[p], src[p]);\r\n    }\r\n  }\r\n  return dest;\r\n}\r\n","import {AGGREGATE_OPS} from '../aggregate';\r\nimport {ORDINAL, QUANTITATIVE} from '../type';\r\nimport {toMap} from '../util';\r\n\r\nexport interface Sort {\r\n  field: string;\r\n  op: string;\r\n  order?: string;\r\n}\r\n\r\nexport var sort = {\r\n  default: 'ascending',\r\n  supportedTypes: toMap([QUANTITATIVE, ORDINAL]),\r\n  oneOf: [\r\n    {\r\n      type: 'string',\r\n      enum: ['ascending', 'descending', 'unsorted']\r\n    },\r\n    { // sort by aggregation of another field\r\n      type: 'object',\r\n      required: ['field', 'op'],\r\n      properties: {\r\n        field: {\r\n          type: 'string',\r\n          description: 'The field name to aggregate over.'\r\n        },\r\n        op: {\r\n          type: 'string',\r\n          enum: AGGREGATE_OPS,\r\n          description: 'The field name to aggregate over.'\r\n        },\r\n        order: {\r\n          type: 'string',\r\n          enum: ['ascending', 'descending']\r\n        }\r\n      }\r\n    }\r\n  ]\r\n};\r\n","/** module for shorthand */\r\n\r\nimport {Encoding} from './schema/encoding.schema';\r\nimport {FieldDef} from './schema/fielddef.schema';\r\nimport {Spec} from './schema/schema';\r\n\r\nimport {AGGREGATE_OPS} from './aggregate';\r\nimport {TIMEUNITS} from './timeunit';\r\nimport {SHORT_TYPE, TYPE_FROM_SHORT_TYPE} from './type';\r\nimport * as vlEncoding from './encoding';\r\n\r\nexport const DELIM = '|';\r\nexport const ASSIGN = '=';\r\nexport const TYPE = ',';\r\nexport const FUNC = '_';\r\n\r\n\r\nexport function shorten(spec: Spec): string {\r\n  return 'mark' + ASSIGN + spec.marktype +\r\n    DELIM + shortenEncoding(spec.encoding);\r\n}\r\n\r\nexport function parse(shorthand: string, data?, config?) {\r\n  let split = shorthand.split(DELIM),\r\n    marktype = split.shift().split(ASSIGN)[1].trim(),\r\n    encoding = parseEncoding(split.join(DELIM));\r\n\r\n  let spec:Spec = {\r\n    marktype: marktype,\r\n    encoding: encoding\r\n  };\r\n\r\n  if (data !== undefined) {\r\n    spec.data = data;\r\n  }\r\n  if (config !== undefined) {\r\n    spec.config = config;\r\n  }\r\n  return spec;\r\n}\r\n\r\nexport function shortenEncoding(encoding: Encoding): string {\r\n  return vlEncoding.map(encoding, function(fieldDef, channel) {\r\n    return channel + ASSIGN + shortenFieldDef(fieldDef);\r\n  }).join(DELIM);\r\n}\r\n\r\nexport function parseEncoding(encodingShorthand: string): Encoding {\r\n  return encodingShorthand.split(DELIM).reduce(function(m, e) {\r\n    var split = e.split(ASSIGN),\r\n        enctype = split[0].trim(),\r\n        fieldDefShorthand = split[1];\r\n\r\n    m[enctype] = parseFieldDef(fieldDefShorthand);\r\n    return m;\r\n  }, {});\r\n}\r\n\r\nexport function shortenFieldDef(fieldDef: FieldDef): string {\r\n  return (fieldDef.aggregate ? fieldDef.aggregate + FUNC : '') +\r\n    (fieldDef.timeUnit ? fieldDef.timeUnit + FUNC : '') +\r\n    (fieldDef.bin ? 'bin' + FUNC : '') +\r\n    (fieldDef.field || '') + TYPE + SHORT_TYPE[fieldDef.type];\r\n}\r\n\r\nexport function shortenFieldDefs(fieldDefs: FieldDef[], delim = DELIM): string {\r\n  return fieldDefs.map(shortenFieldDef).join(delim);\r\n}\r\n\r\nexport function parseFieldDef(fieldDefShorthand: string): FieldDef {\r\n  var split = fieldDefShorthand.split(TYPE), i;\r\n\r\n  var fieldDef: FieldDef = {\r\n    field: split[0].trim(),\r\n    type: TYPE_FROM_SHORT_TYPE[split[1].trim()]\r\n  };\r\n\r\n  // check aggregate type\r\n  for (i in AGGREGATE_OPS) {\r\n    var a = AGGREGATE_OPS[i];\r\n    if (fieldDef.field.indexOf(a + '_') === 0) {\r\n      fieldDef.field = fieldDef.field.substr(a.length + 1);\r\n      if (a === 'count' && fieldDef.field.length === 0) fieldDef.field = '*';\r\n      fieldDef.aggregate = a;\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (i in TIMEUNITS) {\r\n    var tu = TIMEUNITS[i];\r\n    if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\r\n      fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\r\n      fieldDef.timeUnit = tu;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // check bin\r\n  if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\r\n    fieldDef.field = fieldDef.field.substr(4);\r\n    fieldDef.bin = true;\r\n  }\r\n\r\n  return fieldDef;\r\n}\r\n","/* Utilities for a Vega-Lite specificiation */\r\n\r\nimport * as vlEncoding from './encoding';\r\nimport {duplicate} from './util';\r\nimport {Model} from './compiler/Model';\r\nimport {Spec} from './schema/schema';\r\nimport {COLOR, DETAIL} from './channel';\r\nimport {BAR, AREA} from './marktype';\r\n\r\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\r\n\r\nexport function alwaysNoOcclusion(spec: Spec): boolean {\r\n  // FIXME raw OxQ with # of rows = # of O\r\n  return vlEncoding.isAggregate(spec.encoding);\r\n}\r\n\r\nexport function getCleanSpec(spec: Spec): Spec {\r\n  // TODO: move toSpec to here!\r\n  return new Model(spec).toSpec(true);\r\n}\r\n\r\nexport function isStack(spec: Spec): boolean {\r\n  return (spec.encoding[COLOR].field || spec.encoding[DETAIL].field) &&\r\n    (spec.marktype === BAR || spec.marktype === AREA) &&\r\n    (!spec.config || !spec.config.stack !== false) &&\r\n    vlEncoding.isAggregate(spec.encoding);\r\n}\r\n\r\n// TODO revise\r\nexport function transpose(spec: Spec): Spec {\r\n  var oldenc = spec.encoding,\r\n    encoding = duplicate(spec.encoding);\r\n  encoding.x = oldenc.y;\r\n  encoding.y = oldenc.x;\r\n  encoding.row = oldenc.column;\r\n  encoding.column = oldenc.row;\r\n  spec.encoding = encoding;\r\n  return spec;\r\n}\r\n","export const TIMEUNITS = [\r\n  'year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'\r\n];\r\n","/** Constants and utilities for data type */\r\n\r\nexport const QUANTITATIVE = 'quantitative';\r\nexport const ORDINAL = 'ordinal';\r\nexport const TEMPORAL = 'temporal';\r\nexport const NOMINAL = 'nominal';\r\n\r\n/**\r\n * Mapping from full type names to short type names.\r\n * @type {Object}\r\n */\r\nexport const SHORT_TYPE = {\r\n  quantitative: 'Q',\r\n  temporal: 'T',\r\n  nominal: 'N',\r\n  ordinal: 'O'\r\n};\r\n/**\r\n * Mapping from short type names to full type names.\r\n * @type {Object}\r\n */\r\nexport const TYPE_FROM_SHORT_TYPE = {\r\n  Q: QUANTITATIVE,\r\n  T: TEMPORAL,\r\n  O: ORDINAL,\r\n  N: NOMINAL\r\n};\r\n\r\n/**\r\n * Get full, lowercase type name for a given type.\r\n * @param  {String} type\r\n * @return {String} Full type name.\r\n */\r\nexport function getFullName(type: string): string {\r\n  return TYPE_FROM_SHORT_TYPE[type.toUpperCase()] || // short type is uppercase by default\r\n         type.toLowerCase();\r\n}\r\n","/// <reference path=\"../typings/datalib.d.ts\"/>\r\n\r\nexport * from 'datalib/src/util';\r\nexport * from 'datalib/src/generate';\r\nexport * from 'datalib/src/stats';\r\n\r\n\r\nexport function contains(array, item) {\r\n  return array.indexOf(item) > -1;\r\n}\r\n\r\nexport function forEach(obj, f, thisArg) {\r\n  if (obj.forEach) {\r\n    obj.forEach.call(thisArg, f);\r\n  } else {\r\n    for (var k in obj) {\r\n      f.call(thisArg, obj[k], k , obj);\r\n    }\r\n  }\r\n}\r\n\r\nexport function reduce(obj, f, init, thisArg?) {\r\n  if (obj.reduce) {\r\n    return obj.reduce.call(thisArg, f, init);\r\n  } else {\r\n    for (var k in obj) {\r\n      init = f.call(thisArg, init, obj[k], k, obj);\r\n    }\r\n    return init;\r\n  }\r\n}\r\n\r\nexport function map(obj, f, thisArg?) {\r\n  if (obj.map) {\r\n    return obj.map.call(thisArg, f);\r\n  } else {\r\n    var output = [];\r\n    for (var k in obj) {\r\n      output.push( f.call(thisArg, obj[k], k, obj));\r\n    }\r\n    return output;\r\n  }\r\n}\r\n\r\nexport function any(arr: Array<any>, f: (d, k?, i?) => boolean) {\r\n  var i = 0, k;\r\n  for (k in arr) {\r\n    if (f(arr[k], k, i++)) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function all(arr: Array<any>, f: (d, k?, i?) => boolean) {\r\n  var i = 0, k;\r\n  for (k in arr) {\r\n    if (!f(arr[k], k, i++)) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// FIXME remove this\r\nimport dlBin = require('datalib/src/bins/bins');\r\nexport function getbins(stats, maxbins) {\r\n  return dlBin({\r\n    min: stats.min,\r\n    max: stats.max,\r\n    maxbins: maxbins\r\n  });\r\n}\r\n\r\nexport function error(message: any): void {\r\n  console.error('[VL Error]', message);\r\n}\r\n","import {Spec} from './schema/schema';\r\n\r\n// TODO: move to vl.spec.validator?\r\n\r\nimport {toMap} from './util';\r\nimport {schema} from './schema/schema';\r\n\r\ninterface RequiredChannelMap {\r\n  [marktype:string]: Array<string>;\r\n}\r\n\r\n/**\r\n * Required Encoding Channels for each mark type\r\n * @type {Object}\r\n */\r\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\r\n  text: ['text'],\r\n  line: ['x', 'y'],\r\n  area: ['x', 'y']\r\n};\r\n\r\ninterface SupportedChannelMap {\r\n  [marktype:string]: {\r\n    [channel:string]: number\r\n  };\r\n}\r\n\r\n/**\r\n * Supported Encoding Channel for each mark type\r\n */\r\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\r\n  bar: toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\r\n  line: toMap(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\r\n  area: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n  tick: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\r\n  circle: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n  square: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\r\n  point: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\r\n  text: toMap(['row', 'column', 'size', 'color', 'text']) //TODO(#724) revise\r\n};\r\n\r\n// TODO: consider if we should add validate method and\r\n// requires ZSchema in the main vega-lite repo\r\n\r\n/**\r\n  * Further check if encoding mapping of a spec is invalid and\r\n  * return error if it is invalid.\r\n  *\r\n  * This checks if\r\n  * (1) all the required encoding channels for the mark type are specified\r\n  * (2) all the specified encoding channels are supported by the mark type\r\n  * @param  {[type]} spec [description]\r\n  * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\r\n  * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\r\n  * @return {String} Return one reason why the encoding is invalid,\r\n  *                  or null if the encoding is valid.\r\n  */\r\nexport function getEncodingMappingError(spec: Spec,\r\n      requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\r\n      supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\r\n    ) {\r\n  let marktype = spec.marktype;\r\n  let encoding = spec.encoding;\r\n  let requiredChannels = requiredChannelMap[marktype];\r\n  let supportedChannels = supportedChannelMap[marktype];\r\n\r\n  for (let i in requiredChannels) { // all required channels are in encoding`\r\n    if (!(requiredChannels[i] in encoding)) {\r\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\r\n              '\\\" for marktype \\\"' + marktype + '\\\"';\r\n    }\r\n  }\r\n\r\n  for (let channel in encoding) { // all channels in encoding are supported\r\n    if (!supportedChannels[channel]) {\r\n      return 'Encoding channel \\\"' + channel +\r\n             '\\\" is not supported by mark type \\\"' + marktype + '\\\"';\r\n    }\r\n  }\r\n\r\n  if (marktype === 'bar' && !encoding.x && !encoding.y) {\r\n    return 'Missing both x and y for bar';\r\n  }\r\n\r\n  return null;\r\n}\r\n","import * as vlBin from './bin';\r\nimport * as vlChannel from './channel';\r\nimport * as vlData from './data';\r\nimport * as vlEncoding from './encoding';\r\nimport * as vlFieldDef from './fielddef';\r\nimport * as vlCompiler from './compiler/compiler';\r\nimport * as vlSchema from './schema/schema';\r\nimport * as vlShorthand from './shorthand';\r\nimport * as vlSpec from './spec';\r\nimport * as vlTimeUnit from './timeunit';\r\nimport * as vlType from './type';\r\nimport * as vlValidate from './validate';\r\nimport * as vlUtil from './util';\r\n\r\n\r\n\r\nexport var bin = vlBin;\r\nexport var channel = vlChannel;\r\nexport var compiler = vlCompiler;\r\nexport var compile = vlCompiler.compile;\r\nexport var data = vlData;\r\nexport var encoding = vlEncoding;\r\nexport var fieldDef = vlFieldDef;\r\nexport var schema = vlSchema;\r\nexport var shorthand = vlShorthand;\r\nexport var spec = vlSpec;\r\nexport var timeUnit = vlTimeUnit;\r\nexport var type = vlType;\r\nexport var util = vlUtil;\r\nexport var validate = vlValidate;\r\n\r\nexport const version = '__VERSION__';\r\n"],"sourceRoot":"/source/"}